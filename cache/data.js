export const posts = [{"id":"LDF/101/cpp/01-introduction","title":"Introduction","body":"\nIn this workshop, we use CodeQL to analyze the source code of a [vulnerable Linux driver](https://github.com/invictus-0x90/vulnerable_linux_driver) to pinpoint a portion of source code that causes a buffer overflow.\n\nThe Linux kernel allows users to register their simple drivers as a [miscellaneous character driver](https://www.linuxjournal.com/article/2920) (henceforth misc driver), and this project aims to provide a misc driver ready to be inserted into the kernel. Linux misc drivers need to be added and removed to the kernel via two API functions provided by the kernel, [`misc_register`](https://github.com/torvalds/linux/blob/8ca09d5fa3549d142c2080a72a4c70ce389163cd/include/linux/miscdevice.h#L91) and [`misc_unregister`](https://github.com/torvalds/linux/blob/8ca09d5fa3549d142c2080a72a4c70ce389163cd/include/linux/miscdevice.h#L92), respectively.\n\nLooking close to the source code of this project, we can see it [register a vulnerable device](https://github.com/invictus-0x90/vulnerable_linux_driver/blob/2bbfdadd403b6def98f98f6ee3f465286f35e0c9/src/vuln_driver.c#L156) represented as a `static struct` that contains another struct that implements `file_operations` which bridges between user-space application code (performing I/O with the device) and the kernel. The vulnerable point is the `do_ioctl` function being registered as that user-space code, hence the aim of our investigation.\n\nStarting from the `misc_register` function we will traverse function calls, expressions, structure definitions, and variable initializations to find this entrypoint `do_ioctl`. In the course of this investigation, you will learn how to express our interest in a query language CodeQL and learn that we are able to go quite far only by syntactic analysis that combines various constraints together using formulas, predicates, and classes.\n\nThe workshop is split into several steps. You can write one query per step, or work with a single query that you refine at each step. Each step has a **hint** that suggests useful classes and predicates in the CodeQL standard libraries for C/C++. You can explore these in VSCode using the autocomplete suggestions `Ctrl+Space` and the `Go to Definition` command bound to `F12`.\n","topics":"Introduction"},{"id":"LDF/101/cpp/02-setup-instructions","title":"Setup Instructions","body":"\nBefore we move on to write our queries, let us set up our development environment of choice: there are two such ones we recommend: GitHub Codespaces and making a local copy, though we strongly prefer the former.\n\n### GitHub Codespaces\n\nThis is the easiest and fastest way to get started!\n\n1. From the command palette (bound to `Ctrl+Shift+P` or `Cmd+Shift+P`), choose `CodeQL: Choose Database from Archive`.\n2. `cd` to `docs/LDF/101/cpp`.\n3. Run `git lfs pull` to get the precompiled database to work on.\n4. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select `ldf-101-cpp/solutions`, `ldf-101-cpp/tests`, and `ldf-101-cpp/exercises`.\n5. Choose `vld.zip` provided by Git LFS.\n\n### Working locally\n\n1. Install [Visual Studio Code](https://code.visualstudio.com/).\n2. Install the [CodeQL extension for Visual Studio Code](https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/).\n3. Clone this repository and `cd` to `docs/LDF/101/cpp`.\n4. Run `git lfs pull` to get the precompiled database to work on.\n5. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select `ldf-101-cpp/solutions`, `ldf-101-cpp/tests`, and `ldf-101-cpp/exercises`.\n6. From the command palette (bound to `Ctrl+Shift+P` or `Cmd+Shift+P`), choose `CodeQL: Choose Database from Archive`.\n7. Choose `vld.zip` provided by Git LFS.\n\n## Documentation Links\n\nIf you get stuck, try searching our documentation and blog posts for help and ideas. Below are a few links to help you get started:\n\n- [Learning CodeQL](https://codeql.github.com/docs/writing-codeql-queries/)\n- [CodeQL Language Guides for C/C++](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n- [CodeQL Standard Library for C/C++](https://codeql.github.com/codeql-standard-libraries/cpp)\n- [CodeQL](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n- [Using the CodeQL extension for VSCode](https://codeql.github.com/docs/codeql-for-visual-studio-code/)\n","topics":"Setup Instructions"},{"id":"LDF/101/cpp/03-identifying-function-calls","title":"Identifying the Linux Driver API Call","body":"\nWe track the insecure function in question, the I/O function which overflows the buffer, backwards from the API call `misc_register` that registers a vulnerable driver. We take a number of steps to actually get there, so keep track of where we are at and where we are heading towards during the workshop!\n\n## Exercise 1\n\nSince we are first looking for calls to the function `misc_register`, we start off by listing all the function calls in the program. Find all the function calls in the program by implementing Exercise1.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `FunctionCall` can be used to reason about function calls in the program.\n\n</details>\n\n## Exercise 2\n\nThat's a big list of function calls! So let's narrow it down to what we're actually looking for. Filter out rows from the previous table to only have the calls to function `misc_register` by implementing Exercise2.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `FunctionCall` provides the member predicate `getTarget` to refer to the called function.\n- The class `Function` provides the member predicate `getName` to get the name of the function.\n\n</details>\n\nThere should be only one such call if the result is correct. Is that the one inside the definition of `vuln_module_init` as seen below?\n\n```c\n/**\n* Register the device.\n*/\nstatic int vuln_module_init(void)\n{\n    int ret;\n\n    ret = misc_register(&vuln_device);\n\n    ...\n}\n```\n\n## Exercise 3\n\nSo far, we have been adding our constraints to the `where` clause directly. That works, but it makes the `where` clause increasingly hard to read and makes it hard for us to introduce new concepts to be used in some of the constraints. [Predicates](https://codeql.github.com/docs/ql-language-reference/predicates/) and [classes](https://codeql.github.com/docs/ql-language-reference/types/#classes) allow you to do that by capturing logical conditions in a reusable format.\n\nConvert your solution to Exercise2.ql into a CodeQL class in Exercises3.ql by replacing the [none](https://codeql.github.com/docs/ql-language-reference/formulas/#none) formula in the [characteristic predicate](https://codeql.github.com/docs/ql-language-reference/types/#characteristic-predicates) of the `MiscRegisterFunction` class. Also, besides relying on the name, try to add another property to distinguish the function we're looking for. What about the path to the file a program element lives in?\n\n<details>\n<summary>Hints</summary>\n\n- Each program element represented by the class `Element` can be related to the primary file the element occurs in using the member predicate `getFile`.\n- Each program element has an absolute path that can be accessed using the member predicate `getAbsolutePath` on the class `File`.\n- The QL `string` type provides [built-in member predicates](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string) such as `matches` and `regexpMatch` to match patterns in strings. The `matches` predicate interprets `_` to match any single character and `%` to match any sequences of characters in the provided pattern.\n\n</details>\n","topics":"Identifying the Linux Driver API Call"},{"id":"LDF/101/cpp/04-reasoning-about-miscdevice","title":"Reasoning about the Driver Definition","body":"\nNow that we found the call to `misc_register` in question, we shift gears to its argument `&vuln_device`, a representation of the problematic driver. This seems interesting, so let us inspect this object in detail.\n\n## Exercise 4\n\nFirst, identifying the type of the object `vuln_device` might be a good start. Obtain the argument to the call to `misc_register`, the argument's type and the QL class that most precisely represents it by implementing Exercise4.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `FunctionCall` provides the member predicate `getArgument` to get an argument by index.\n- Each expression represented by the class `Expr` has a type that can be retrieved with the member predicate `getType`.\n- Each program element represented by the class `Element` has a member predicate `getPrimaryQlClass` that returns the QL class that is the most precise syntactic category the element belongs to.\n- Relate QL expressions as much as you can. Relate the call to the misc_register call to the misc_register function, use it to retrieve its argument, and again associate to its type and the primary QL class. `Select` the latter three.\n\n</details>\n\nDoes the result indicate that the argument `&vuln_device` is some address of an expression?\n\n## Exercise 5\n\nThe `vuln_device` object is of type `struct miscdevice`, defined in one of the Linux headers. If we represent this `struct`, it may be useful later on. Why don't we model it as a class called `MiscDeviceStruct`? Complete the characteristic predicate of the class `MiscDeviceStruct` in Exercise5.ql so we can reason about its use.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Struct` inherits the member predicate `getName` from the class `UserType` that returns the name of the struct.\n- Each program element represented by the class `Element` can be related to the primary file the element occurs in using the member predicate `getFile`.\n- Each program element has an absolute path that can be accessed using the member predicate `getAbsolutePath` on the class `File`.\n- The QL `string` type provides [built-in member predicates](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string) such as `matches` and `regexpMatch` to match patterns in strings. The `matches` predicate interprets `_` to match any single character and `%` to match any sequences of characters in the provided pattern.\n\n</details>\n\n## Exercise 6\n\nNow that we have the representation of `struct miscdevice`, we can look for all it instantiations. Implement the characteristic predicate of the class `MiscDeviceDefinition` in Exercise6.ql so we can use it to find all its instances.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Variable` has a member predicate `getType` that gets the type of this variable.\n\n</details>\n\n## Exercise 7\n\nThe instantiation `vuln_device` initializes 3 members of the `miscdevice` structure:\n\n1. `minor`: initialized as `MISC_DYNAMIC_MINOR`, so that the device gets a unique minor number on the fly.\n2. `name`: initialized as `DEVICE_NAME`, an alias to string `\"vulnerable_device\"`.\n3. `fops`: this field denotes a file/IO operation to be performed for this device.\n\nThe third ones seems interesting. What is its type? Find the type of the third field initialized with `&vuln_fops` by completing Exercise7.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Struct` inherits the member predicate `getAMember` from the class `Class` that gets the zero-based indexed member declared in the struct.\n- The class `Field` inherits the member predicate `getType` from the class `MemberVariable` that returns the type of the field.\n- Relate the QL expressions as much as possible. Relate the third field of the `misc_device` struct to its field with a suitable predicate, then associate the field to its type with another predicate. `Select` the type.\n\n</details>\n","topics":"Reasoning about the Driver Definition"},{"id":"LDF/101/cpp/05-reasoning-about-device-definition","title":"Finding the Function that Overflows a Buffer","body":"\nWe are now ready to find the culprit that is responsible for overflowing a buffer! As you have notices, that code is injected into the kernel by being included in the driver definition and registered to the kernel.\n\n### Exercise 8\n\nHaving known what type the third field of `struct miscdevice` has, we can now identify all `file_operation`s such as `vuln_ops`. Implement the characteristic predicates for the class `FileOperationsStruct` and `FileOperationsDefinition` in Exercise8.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Struct` inherits the member predicate `getName` from the class `UserType` that gives the name of the struct.\n- Each program element represented by the class `Element` can be related to the primary file the element occurs in using the member predicate `getFile`.\n- Each program element has an absolute path that can be accessed using the member predicate `getAbsolutePath` on the class `File`.\n- The QL string type provides [builtins](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string) such as `matches` and `regexpMatch` to match patterns in strings. The `matches` builtin member predicate interprets `_` to match any single character and `%` to match any sequences of characters in the provided pattern.\n\n</details>\n\n### Exercise 9\n\nThe single file operation definition `vuln_ops` is initialized with, among others, a function pointer for the field `unlocked_ioctl`. This is the function that is invoked when a user-mode application performs the `ioctl` system call to communicate to the driver.\n\nExtend the class `FileOperationsDefinition` with a member predicate `getUnlockedIoctl` that returns a `Function` with which the file operations definition is initialized in\nExercise9.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Variable` has the member predicate `getAnAssignedValue` that returns an `Expr` representing an expression that is assigned to this variable somewhere in the program.\n- The class `Field` inherits the member predicate `hasName` from the class `Declaration` that holds if the field has the provided name.\n- The class `ClassAggregateLiteral` has the member predicate `getFieldExpr` that returns an `Expr` that is part of the aggregate literal that is used to initialize the provided field.\n\nDid you find the function referred to by the pointer?\n\n</details>\n","topics":"Finding the Function that Overflows a Buffer"},{"id":"LDF/101/cpp/06-putting-it-all-together","title":"Putting it all together","body":"\nWe are almost there and we have all the necessary QL definitions to be assembled into a complete query! Now we refactor our code first, and then connect every bit together to complete this workshop.\n\n### Exercise 10\n\nWe have successfully identified the miscellaneous driver definition (`miscdevice`), the file operations definition (`vuln_ops`), and linked the ioctl handler (`do_ioctl`) to the definition of type `file_operations`. Now, we would like to include the act of getting the `file_operation` of `struct miscdevice` under the class which expresses that very `struct miscdevice`, much like encapsulation in object-oriented languages.\n\nGet the class `MiscDeviceStruct` that represents `struct miscdevice` we wrote at Exercise 5, and add a [member predicate](https://codeql.github.com/docs/ql-language-reference/types/#member-predicates) `getFileOperations` that returns a `FileOperationsDefinition` that the miscellaneous driver definition is initialized with in Exercise10.ql.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Variable` has the member predicate `getAnAssignedValue` that returns an `Expr` representing an expression that is assigned to this variable somewhere in the program.\n- The class `Field` inherits the member predicate `hasName` from the class `Declaration` that holds if the field has the provided name.\n- The class `ClassAggregateLiteral` has the member predicate `getFieldExpr` that returns an `Expr` that is part of the aggregate literal that is used to initialize the provided field.\n- A class can be cast to a subclass using the syntax `variable.(Class).predicate()`. For example, to cast an expression `expr` to a `AddressOfExpr` to get an operand of the expression you can use the syntax `expr.(AddressOfExpr).getOperand()`.\n- The class `AddressOfExpr` that represents the expression taking the address `&expr` has a member predicate `getOperand` that returns the expression of which the address is taken.\n- The class `Variable` has a member predicate `getAnAccess` that returns all the access to this variable.\n\n</details>\n\n### Exercise 11\n\nLet's put everything together we've done so far by weaving these classes into one:\n\n1. `MiscRegisterFunction`,\n2. `MiscDeviceDefinition`, and\n3. `FileOperationsDefinition`.\n\nAs a result, we will be able to chain the program elements from the misc_register function call, all the way to `do_ioctl` function.\n\nImplement the characteristic predicate for the class `MiscDriverUserModeEntry` in Exercise11.ql that relates the classes `MiscRegisterFunction`, `MiscDeviceDefinition`, and `FileOperationsDefinition` such that its covers the call to `misc_register` and all the way to the definition of `do_ioctl`.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Function` has a member predicate `getACallToThisFunction` that returns all the function call to this function.\n- The class `FunctionCall` inherits the member predicate `getArgument` from the class `Call` that returns the nth argument for this call.\n- A class can be casted to a subclass using the syntax `variable.(Class).predicate()`. For example, to cast an expression `expr` to a `AddressOfExpr` to get an operand of the expression you can use the syntax `expr.(AddressOfExpr).getOperand()`.\n- The class `Variable` has a member predicate `getAnAccess` that returns all the access to this variable.\n\n</details>\n\nNow, we can run this final query that successfully identifies the vulnerable function. Is the result as described?\n","topics":"Putting it all together"},{"id":"LDF/101/cpp/07-conclusion","title":"Conclusion","body":"\nIn this workshop, we have seen how QL represents a program as a queryable AST that can be effectively used for reasoning about various program elements in relation to others as well as identifying them, and using only those to identify a vulnerable function.\n\nWe have also learned how to express conditions in a reusable manner by leveraging the object-oriented type system of QL, through refactoring our code into predicates and classes.\n","topics":"Conclusion"},{"id":"LDF/101/cpp","title":"Elements of Syntactical Program Analysis I for C/C++","body":"\n## Introduction\n\nAn Abstract Syntax Tree (AST) is a representation of a given program that exposes its syntactic structure. The AST is much like a parse tree, but more concise and to-the-point, which makes it a convenient tool to investigate into simple topics such as whether the program contains a certain element, up to more complex ones such as whether it follows a certain structural pattern. These properties are static by nature, so these analyses provide high precision.\n\nWe learn how to query the AST of a C program and refactor it along the way by investigating a buffer overflow vulnerability in a sample Linux driver. We first start by identifying the point where the program inserts a driver definition to the kernel by using one of its APIs, and climb up the dependency chain by finding definitions and initializations of the types and objects used in the program. Finally, we reach the vulnerable function in question.\n\nBy following through the workshop, we:\n\n- Discover how QL represents C/C++ program elements.\n- Learn how to Query program elements in the AST ([Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)).\n- Learn how to express descriptions of certain program elements using QL classes.\n","topics":"syntactical, C, AST, buffer-overflow, linux"},{"id":"LDF/101","title":"LDF-101 - Elements of Syntactical Program Analysis I","body":"\n## Workshop Description\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\nincididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat\nblandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque\nviverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus\ndictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis\nlectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus\nfeugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra\nvitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et\nsollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum\nat varius vel.\n","topics":"LDF-101 - Elements of Syntactical Program Analysis I"},{"id":"LDF/101/python","title":"Elements of Syntactical Program Analysis I for Python","body":"\n## Introduction\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat blandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque viverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus dictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis lectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus feugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra vitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et sollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum at varius vel.\n\nWrite a thing that can work through the list of things and do a thing.\n","topics":"Elements of Syntactical Program Analysis I for Python"},{"id":"LDF/102/cpp/01-setup-instructions","title":"Setup Instructions","body":"\nBefore we move on to write our queries, let us set up our development environment of choice: there are two such ones we recommend: GitHub Codespaces and making a local copy, though we strongly prefer the former.\n\n### GitHub Codespaces\n\nThis is the easiest and fastest way to get started!\n\n1. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select `ldf-102-cpp/solutions`, `ldf-101-cpp/exercises`, `ldf-102-cpp/solutions-test`, and `ldf-101-cpp/exercises-test`.\n\n### Working locally\n\n1. Install [Visual Studio Code](https://code.visualstudio.com/).\n2. Install the [CodeQL extension for Visual Studio Code](https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/).\n3. Clone this repository and `cd` to `docs/LDF/101/cpp`.\n4. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select `ldf-102-cpp/solutions`, `ldf-101-cpp/exercises`, `ldf-102-cpp/solutions-test`, and `ldf-101-cpp/exercises-test`.\n\n## Documentation Links\n\nIf you get stuck, try searching our documentation and blog posts for help and ideas. Below are a few links to help you get started:\n\n- [Learning CodeQL](https://codeql.github.com/docs/writing-codeql-queries/)\n- [CodeQL Language Guides for C/C++](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n- [CodeQL Standard Library for C/C++](https://codeql.github.com/codeql-standard-libraries/cpp)\n- [CodeQL](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n- [Using the CodeQL extension for VSCode](https://codeql.github.com/docs/codeql-for-visual-studio-code/)\n","topics":"Setup Instructions"},{"id":"LDF/102/cpp/02-control-flow","title":"What is Control Flow?","body":"\nControl flow is an ordering on program elements that dictates the order in which program elements are executed or evaluated.\nThe control flow of a program is captured by a control flow graph that has labelled directed edges between nodes that capture the order and conditions for the flow to occur.\n\nWhen CodeQL extracts code, it will create an abstract syntax tree (AST), and based on the AST it will create a control flow graph (CFG) to capture the order of execution.\nThe CodeQL standard library for C/C++ computes an expression-level intra-procedural CFG and exposes the CFG via the class `ControlFlowNode` and the successor relation `getASuccessor`.\nThis means that the CFG has edges between expressions, statements, and methods.\nAn important goal of the computed CFG is to accurately capture the order of side-effects in a program.\n\nConsider the following snippet:\n\n```cpp\nint add(int m, int n) {\n  return m + n;\n}\n```\n\nThe following AST captures the parent child relationship and based on that relationship the following CFG is generated.\nThe edges are labelled with the order for clarification and are not part of the actual CFG.\n\nLooking at the CFG we can make a few observations:\n\n- For expression (e.g., `AddExpr`) their children are executed from left to right before the expression itself is executed (post-order traversal on the AST node).\n- Statements with side-effects (e.g, `ReturnStmt`) are executed like expression.\n- Statements without side-effects (e.g, `BlockStmt`) are their own entry point (pre-order traversal on the AST node).\n- The method itself is the last node of the CFG.\n\n```text\n\n                 AST                       ┌───────────────┐                           CFG\n                                           │ Unconditional │\n                                           └───────────────┘\n\n             .─────────.                                                           .─────────.\n            ( Function  )                                                         ( Function  )◀────┐\n             `─────────'                                                           `─────────'      │\n                  │                                                                                 │\n                                                                                                    │\n                  │                                                                                 │\n                  ▼                                                                                 │\n             .─────────.                                                            .─────────.     │\n            ( BlockStmt )                                        ────────(1)──────▶( BlockStmt )    │\n             `─────────'                                                            `─────────'     │(6)\n                  │                                                                      │          │\n                                                                ┌────────────────────────┘          │\n                  │                                             │                                   │\n                  ▼                                             │    (2)                ┌───────────┘\n             .─────────.                                        │                       │\n            (ReturnStmt )                                       │                       │\n             `─────────'                                        │                       │\n                  │                                             │                       │\n                                                                │                       │\n                  │                                             ▼                       │\n                                                          .───────────.                 │\n                  ▼                                      ( ReturnStmt  )           .─────────.\n             .─────────.                                  `───────────'           (  AddExpr  )◀───────┐\n            (  AddExpr  )                                       │                  `─────────'         │\n             `─────────'                                        │ (3)                              (5) │\n                  Λ                                             │                                      │\n          ─ ─ ─ ─   ─ ─ ─ ─ ─ ─                                 ▼                                      │\n        ▼                       ▼                       .───────────────.                      .───────────────.\n .─────────────.         .─────────────.               ( VariableAccess  )─────────(4)───────▶( VariableAccess  )\n(VariableAccess )       (VariableAccess )               `───────────────'                      `───────────────'\n `─────────────'         `─────────────'\n```\n\nEach CFG node in the previous example has a single successor.\nWhen we include constructs like conditions or loops, we will encounter CFG nodes with multiple successors.\n\nConsider the following snippet:\n\n```cpp\nunsigned int absolute(int i) {\n  if (i < 0) {\n    return -i;\n  }\n  return i;\n}\n```\n\nFor which we generate the following AST and CFG:\n\n```text\n\n                             AST                                                                             CFG\n\n                          .───────.                                                                       .───────.\n                         (Function )                                                                     (Function )◀───────────────────────────────────────────┐\n                          `───────'                              ┌───────────────┐                        `───────'                                             │\n                              │                                  │  Conditional  │                            ▲                                                 │\n                              │                                  └───────────────┘                            │                                                 │\n                              │                                                                               └─────────────────────────────────────────────────┼──┐\n                              ▼                                                                                                                                 │  │\n                         .─────────.                                                                     .─────────.                                            │  │\n                        ( BlockStmt )                                                      ────────────▶( BlockStmt )                                           │  │\n                         `─────────'                                                                     `─────────'                                            │  │\n                              │                                                                               │                                                 │  │\n                              │                                                                               │                                                 │  │\n                              │                                                                               │                                                 │  │\n                              ▼                                                                               ▼                                                 │  │\n                          .───────.                                                                       .───────.                                             │  │\n                         ( IfStmt  )                                                                     ( IfStmt  )                                            │  │\n                          `───────'                                                                       `───────'                                             │  │\n                              │                                                                               │                                                 │  │\n                              │                                                                               │                                                 │  │\n                 ┌────────────┴────────────────┬───────────────────┐                    ┌─────────────────────┘                                                 │  │\n                 │                             │                   │                    │        ┌────────────────────────────(false)──────────────┐            │  │\n                 ▼                             ▼                   ▼                    │        │                                                 ▼            │  │\n             .───────.                    .─────────.         .─────────.               │    .───────.                    .─────────.         .─────────.       │  │\n            ( LTExpr  )                  ( BlockStmt )       ( BlockStmt )              │   ( LTExpr  )─────────────────▶( BlockStmt )       ( BlockStmt )      │  │\n             `───────'                    `─────────'         `─────────'               │    `───────'       (true)       `─────────'         `─────────'       │  │\n                 │                             │                   │                    │        ▲                             │                   │            │  │\n        ┌────────┴────────┐                    │                   │                    │        └────────┐                    │                   │            │  │\n        │                 │                    │                   │                    │                 │                    │                   │            │  │\n        ▼                 ▼                    ▼                   ▼                    ▼                 │                    ▼                   ▼            │  │\n .─────────────.   .─────────────.      .─────────────.     .─────────────.      .─────────────.   .─────────────.      .─────────────.     .─────────────.     │  │\n(VariableAccess ) (    Literal    )    (  ReturnStmt   )   (  ReturnStmt   )    (VariableAccess ) (    Literal    )    (  ReturnStmt   )   (  ReturnStmt   )    │  │\n `─────────────'   `─────────────'      `─────────────'     `─────────────'      `─────────────'   `─────────────'      `─────────────'     `─────────────'     │  │\n                                               │                   │                    │                 ▲                    │                   │            │  │\n                                               ▼                   ▼                    │                 │        ┌───────────┘                   ▼            │  │\n                                       .───────────────.   .───────────────.            └─────────────────┘        │   .───────────────.   .───────────────.    │  │\n                                      ( UnaryMinuxExpr  ) ( VariableAccess  )                                      │  ( UnaryMinuxExpr  ) ( VariableAccess  ) ──┘  │\n                                       `───────────────'   `───────────────'                                       │   `────────────┬──'   `───────────────'       │\n                                               │                                                                   │           ▲    │                              │\n                                               │                                                                   │           │    └──────────────────────────────┘\n                                               ▼                                                                   │           │\n                                       .───────────────.                                                           │   .───────────────.\n                                      ( VariableAccess  )                                                          └─▶( VariableAccess  )\n                                       `───────────────'                                                               `───────────────'\n```\n\nHere we can see a CFG with a node that has multiple successors.\nThe `LTExpr` part of the condition in the `IfStmt` statement continues execution to one of two successors depending on whether the condition evaluates to `true` or `false`.\nThis is reflected in the labels of the outgoing CFG edges.\n\nIn the next section we will see how we can use the control flow graph to find control flow nodes that are of interest to us.\n","topics":"What is Control Flow?"},{"id":"LDF/102/cpp/03-finding-control-flow-nodes","title":"Finding Control Flow Nodes","body":"\nFind all the control flow nodes and their successors by implementing `src/exercises/Exercise1.ql`.\n\n<details>\n<summary>Hints</summary>\n\n- The `cpp` module provides a class `ControlFlowNode` to reason about control flow nodes in a program.\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise1.ql`.\n","topics":"Finding Control Flow Nodes"},{"id":"LDF/102/cpp/04-reachability","title":"Control Flow and Reachability","body":"\nNow that we have described how two control flow nodes relate using the successor relationship we can reason about reachability.\n\nReachability is a concept from graph theory that refers to the ability to get from one vertex to another within a graph.\nIn our case it means that control can be transferred from one node in the CFG to another node in the CFG.\nOr more concretely, the reachable node will be executed after executing the node it is reachable from.\n\nImplement the _predicate_ `reachable` using the successor relationship by completing the query `src/exercises/Exercise2.ql`.\n\n<details>\n<summary>Hints</summary>\n\nThis query can be implemented using [recursion](https://codeql.github.com/docs/ql-language-reference/recursion/#recursion) or using the [transitive closure](https://codeql.github.com/docs/ql-language-reference/recursion/#transitive-closures)\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise2.ql`.\n","topics":"Control Flow and Reachability"},{"id":"LDF/102/cpp/05-restricting","title":"Restricting Control Flow","body":"\nTo visualize the intra-procedural CFG, that is the CFG of a method not crossing method boundaries, restrict the begin node and the reachable node by completing the query in  `src/exercises/Exercise3.ql`.\n\nTo understand how to restrict the begin node and the end node we first have to determine what a begin node and end node in a CFG are with respect to the _successor_ relationship.\n\n<details>\n<summary>Hints</summary>\n\n- The `ControlFlowNode` class has member predicate `getAPredecessor` to get a predecessor. How could you get a predecessor with only the `getASuccessor` member predicate?\n- You can use the pattern `not exists(...)` to state that a predicate has no results.\n- The CodeQL CLI command `codeql database analyze` can output to the `dot` format. The result can be rendered with Graphviz. See the file `control-flow-graph.png` for a rendering of the control flow graphs in `src/`exercises-tests/Exercise3/test.cpp`.\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise3.ql`.\n","topics":"Restricting Control Flow"},{"id":"LDF/102/cpp/06-stmt-expr","title":"Statement Successors","body":"\nFrom the results of the previous exercises, we can see that the control flow paths include both statements and expressions.\nIn some cases, you would be interested in determining the successor statement of another statement.\nFor example, given an _if_ statement, what is the next reachable _if_ statement.\nOur `reachable` predicate will return all reachable _if_ statement so additional logic is required to answer the question.\n\nImplement the predicate `getANextStmt` in `src/exercises/Exercise4.ql`.\nWhile implementing the predicate consider the following C/C++ snippet and which `if` statements should be returned by `src/exercises/Exercise4.ql` for the first `if` statement.\n\n```cpp\nif (...) {\n  if (...) {\n    ...\n  }\n}\n\nif (...) {\n  ...\n}\n```\n\nwith the following CFG.\n\n```text\n                   │\n                   │\n                   │\n                   │\n                   ▼\n               .───────.\n              ( IfStmt  )\n               `───────'\n                   │\n     ┌─────────────┘\n     ▼\n .───────.               .───────.\n(   ...   )───(true)───▶(BlockStmt)\n `───────'               `───────'\n     │                       │\n     │                       │\n     │                       ▼\n     │                   .───────.\n     │                  ( IfStmt  )\n     │                   `───────'\n     │                       │\n  (false)         ┌──────────┘\n     │            ▼\n     │       .───────.              .───────.\n     │      (   ...   )─(true)────▶(BlockStmt)\n     │       `───────'              `───────'\n     │           │                      │\n     │           │                      │\n     │        (false)                   │\n     │           │                      │\n     │           ▼                      ▼\n     │       .───────.              .───────.\n     └─────▶( IfStmt  )◀───────────(   ...   )\n             `───────'              `───────'\n                 │\n        ┌────────┘\n        ▼\n    .───────.          .───────.\n   (   ...   )───────▶(   ...   )─ ─ ─ ─ ─▶\n    `───────'          `───────'\n```\n\n<details>\n<summary>Hints</summary>\n\nWhen you use the `reachable` predicate you need to exclude results to include only the strict successor statements.\nHowever, you cannot exclude the correct nodes due to conditional nodes. See the above example snippet and CFG.\n\nTo implement a correct solution, you need to resort to a _recursive_ predicate.\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise4.ql`.\n","topics":"Statement Successors"},{"id":"LDF/102/cpp/07-using-reachability","title":"Using Reachability","body":"\nNow that we understand the _successor_ relation, the control flow graph, and _reachability_, we can look at how reachability can be used.\n\nIn multiple scenarios, including security relevant scenarios, a certain action must be performed before another action.\nFor example, before you can use a method you must first initialize the class providing the method.\n\nLook at the `test/exercises/Exercise5/test.cpp` for `src/exercises/Exercise5.ql` and implement `src/exercises/Exercise5.ql` to ensure the `incorrect_use` is detected.\n\n<details>\n<summary>Hints</summary>\n\nFor all correct uses, the `some_action` method access is reachable from the `init` function call.\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise5.ql`.\n","topics":"Using Reachability"},{"id":"LDF/102/cpp/08-reachability-scopes","title":"Domination and Scopes in Reachability Analysis","body":"\nFirst time use of the _successor_ relationship and _reachability_ can result in surprising result.\nThe _successor_ relationship relates program elements that can reside in different scopes within a method.\n\nFor example, any program element following an `if` statement will be related to one or more statements in the `if` body.\nConsider the following case:\n\n```cpp\nvoid incorrect_use2(const char *input) {\n  struct ctx ctx;\n\n  if (input) {\n    init(&ctx);\n  }\n\n  some_action(&ctx, input);\n}\n```\n\nThe `some_action` method access is reachable from an `init` function call.\nThis means that the solution to exercise 5 will not find this incorrect use, which is the case for our solution to exercise 5.\n\nTo ensure that all accesses of the method `some_action` are preceded by an `init` access we can make use of the [dominator](https://en.wikipedia.org/wiki/Dominator_(graph_theory)) concept from graph theory.\nA node **dominates** another node if every path from the _entry node_ to a node _m_ must go through node _n_.\nIf we swap _m_ with method access for `someAction`  and _n_ with method access of `initialize` then this describes the property we want.\n\nThe standard library provides the predicate `dominates` that is defined in the the module [Dominance](https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/controlflow/Dominance.qll/module.Dominance.html).\n\nUse the predicate `dominates` and update the solution to `src/exercises/Exercise5.ql` in  `src/exercises/Exercise6.ql` to account for the new case.\n\n<details>\n<summary>Hints</summary>\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise6.ql`\n","topics":"Domination and Scopes in Reachability Analysis"},{"id":"LDF/102/cpp/09-extending-analysis","title":"Extending Control Flow Analysis","body":"\nCodeQL constructs an intraprocedural CFG, meaning it only considers the program elements in a function.\nHowever, function are not used in isolation and there are cases where we need to extend the control flow analysis.\n\nThe test case `test/exercises/Exercise7/test.cpp` is extended with the function `default_ctx` that initializes the context and sets some fields to default values.\nTo detect this case we need to reason about the control flow graph interprocedurally.\nThe reasoning about _callers_ and _callees_, flow of control crossing function boundaries, requires the use of the (static) [Call graph](https://en.wikipedia.org/wiki/Call_graph).\n\nTo be able to correctly identify the `correct_use2` case we need to determine that there exists a _function call_ that _dominates_ the _function call_ `some_action` and confirm that the _function call_ always call the `init` method.\n\nImplement `src/exercises/Exercise7.ql` by completing the predicates `initCallDominatesExit`, that holds if a function calls the `init` function on all execution paths, and `callAlwaysCallsInit`, that holds if a function call calls a function that always calls `init` on all execution paths.\n\n<details>\n<summary>Hints</summary>\n\n- The predicate `dominates` holds if a control flow node can only be reached by going through another control flow node.\n- The `Function` is the last node in the control flow graph of a function.\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise7.ql`.\n","topics":"Extending Control Flow Analysis"},{"id":"LDF/102/cpp/10-extending-analysis-further","title":"Extending Interprocedural Analysis Further","body":"\nIn the previous exercise we started to reason interprocedurally about the control flow.\nHowever, our reasoning was incomplete because we only considered calls dominating the `some_action` function call within the same function.\n\nConsider the test case `test/exercises/Exercise8/test.cpp` that includes multiple calls to `correct_or_incorrect_use` where one caller has initialized the context and the other is didn't.\n\nTo identify the correct uses, we need to determine if all the _callers_ of `correct_or_incorrect_use` are dominated by an `init` function call, or a function call that always performs calls the `init` function.\n\nImplement the query `alwaysPrecededByInitializationCall` in `src/exercises/Exercise8.ql` and use it to determine that a `ControlFlowNode` is always directly preceded by an `init` function call, or the property holds for all the callers of its enclosing callable.\n\n<details>\n<summary>Hints</summary>\n\n- The `FunctionCall` class has a member predicate `getTarget` to reason about the functions it can call.\n- The `ControlFlowNode` class has a member predicate `getControlFlowScope` to reason about the function that contains the control flow node.\n- To state that a property must hold for all values (e.g., all callers) use the formula [forall](https://codeql.github.com/docs/ql-language-reference/formulas/#forall). Note that the `forall` formula holds vacuously if there are no values to test the property on because it is logicall the same as `not exists(<vars> | <formula 1> | not <formula 2>)`.\nIf there needs to be at least one value for which the property holds you can use the [forex](https://codeql.github.com/docs/ql-language-reference/formulas/#forex) formula.\n\n</details>\n\nA solution can be found in the query `src/solutions/Exercise8.ql`.\n","topics":"Extending Interprocedural Analysis Further"},{"id":"LDF/102/cpp/11-handling-corner-cases","title":"Corner Cases in Control Flow","body":"\nMultiple corner cases down the line the question arises whether there isn't a better way to solve our problem.\nWhile our solutions improved incrementally, we still have a lot of corner cases to cover.\nFor example, we didn't even consider that the arguments to the `init` calls are the same as to the `some_action` calls.\n\nThe answer to the question is yes. Data flow analysis allows us to more succinctly describe the problem and provide us with more precise answers.\nHowever, for the correct answer, we still need to reason about control flow.\n\nAs a precursor to the data flow workshop, we are going to implement parts of an interprocedural dataflow configuration to find uses of `some_action` without a preceding call to `init`. The core idea is to track the struct's instance to its uses as an argument to `some_action` calls and stop tracking the instance if it is used as an argument to `init`.\nHowever, because C/C++'s data flow implementation relies on _def-use_ relations, and not on _use-use_ relations, we still need the predicates we created so far to filter out correct uses.\n\nComplete the dataflow configuration in `src/solutions/Exercise9.ql`.\n\n<details>\n<summary>Hints</summary>\n- The class `DataFlow::Node` can transformed to uninitialized local variables using the member predicate `asUninitialized`.\n- The class `LocalVariable` has a member predicate `getType()` to get the type of the variable.\n- Interprocedural dataflow uses the concepts of a _source_ and a _sink_ for which it determines if the source can reach the sink.\n  A barrier is a condition that prevents further analysis to determine if a sink is reachable and is typically used to exclude data that is sanitized or validated.\n</details>\n\nA solution can be found in the query `src/solutions/Exercise9.ql`.\n","topics":"Corner Cases in Control Flow"},{"id":"LDF/102/cpp","title":"Reasoning about Control Flow I for C/C++","body":"\n## Introduction\n\n\"LDF-102 - Reasoning about Control Flow I\" is a comprehensive workshop designed to introduce and deepen your understanding of using CodeQL to reason about control flow in your code. CodeQL, a powerful semantic code analysis engine, allows you to explore your codebase in a way that goes beyond syntax-based analysis. This workshop will guide you through the process of using CodeQL to identify and understand the control flow paths in your code, which is crucial for detecting potential vulnerabilities and bugs.\n\nContrasting this with syntax-based analysis, CodeQL offers a more profound and insightful analysis. While syntax-based analysis focuses on the structure of the code, CodeQL delves deeper into the semantics of the code, providing a more accurate and detailed understanding of the code's behavior. This difference makes CodeQL a more powerful tool for code analysis, as it can identify complex code patterns and potential issues that might be missed by a syntax-based analysis.\n\nIn this workshop, you will learn how to use CodeQL to analyze control flow in a variety of contexts. You will gain insights into how control flow can affect the behavior of your code, and how to use this knowledge to improve your code quality. You will also learn how to write your own CodeQL queries to explore and reason about the control flow in your codebase. This knowledge will empower you to identify and fix potential issues in your code, leading to more robust and secure software.\n\nThe workshop is split into multiple exercises introducing control flow.\nIn these exercises you will learn:\n\n- About control flow and the control flow graph (CFG).\n- How control flow is represented in QL.\n- Learn about reachability and how you can answer reachability questions using recursive predicates and transitive closures.\n- About properties of control flow graph nodes, such as dominating other control flow nodes.\n- About corner-cases when reasoning using control flow, how data flow provides higher level construct to answer reachability questions, but still requires control flow to excludes correct cases.\n","topics":"syntactical, C, AST, Control Flow, linux"},{"id":"LDF/102","title":"LDF-102 - Reasoning about Control Flow I","body":"\n## Workshop Description\n\nIn the LDF-101 series of workshops we learned about how to reason about the syntax of a program. In LDF-101, you used the literal text of the program and used CodeQL to look for relevant items from a security-focused context.\n\n\"LDF-102 - Reasoning about Control Flow I\" is a comprehensive workshop designed to introduce and deepen your understanding of using CodeQL to reason about control flow in your code. CodeQL, a powerful semantic code analysis engine, allows you to explore your codebase in a way that goes beyond syntax-based analysis. This workshop will guide you through the process of using CodeQL to identify and understand the control flow paths in your code, which is crucial for detecting potential vulnerabilities and bugs.\n\nContrasting this with syntax-based analysis, CodeQL offers a more profound and insightful analysis. While syntax-based analysis focuses on the structure of the code, CodeQL delves deeper into the semantics of the code, providing a more accurate and detailed understanding of the code's behavior. This difference makes CodeQL a more powerful tool for code analysis, as it can identify complex code patterns and potential issues that might be missed by a syntax-based analysis.\n\nIn this workshop, you will learn how to use CodeQL to analyze control flow in a variety of contexts. You will gain insights into how control flow can affect the behavior of your code, and how to use this knowledge to improve your code quality. You will also learn how to write your own CodeQL queries to explore and reason about the control flow in your codebase. This knowledge will empower you to identify and fix potential issues in your code, leading to more robust and secure software.\n","topics":"LDF-102 - Reasoning about Control Flow I"},{"id":"LDF/103/cpp/01-introduction","title":"Introduction","body":"\nIn this workshop, we will use CodeQL to analyze the source code of\n[CoreCLR](https://github.com/dotnet/coreclr), the runtime for .NET\nCore, to see if there are possible attack vectors of a [format string injection vulnerability](https://owasp.org/www-community/attacks/Format_string_attack).\n\nCoreCLR contains a debugger called `createdump` which provides dumping functionalities for later inspection. The `createdump` command accepts flagged arguments supplied from outside the program and it can lead to format string vulnerability:\n\n1. A user invokes the `createdump` command and passes an `-f` flag to create a dump file and supplies a format string `\"%p\"` for the `--name` parameter (A printf call with `\"%p\"` as its format string reveals the current stack position of the host machine). This abuses the `--name` parameter as it is originally intended to be a file path to write the dump file to.\n2. `dumpFilePath` is handed this format string from `argv`.\n3. `dumpFilePath` is passed to `CreateDumpCommon` of `createdump.cpp`.\n4. `CreateDumpCommon` uses `dumpFilePath` as the format string to `snprintf`.\n\nSuch untrusted (_tainted_) non-constant format strings can be detected using local taint flow only; if the variable is placed at the format string position of `snprintf`, we can suspect the format string the variable points to is supplied from outside the program by an attacker. However, that is not the case if every caller of `CreateDumpCommon` passes a hard-coded string literal to it. Therefore, we cannot be sure of whether if the format string variable is actually controllable from the outside without looking between procedures, that is, looking into the global taint flow.\n\nBut global taint flows are not feasible to compute for all functions in a database because the number of paths becomes _exponentially_ larger for global taint flow, making it infeasible to build a reachability table for the whole program, given any reasonably sized one. That is, constructing the table is bounded by `O(n*n)` where `n` is the number of taint flow nodes in the _entire_ program.\n\nThe global taint tracking library avoids this problem by requiring that the query specifies what _sources_ and _sinks_ to look for. This allows CodeQL to compute paths containing only the restricted set of nodes between the specified sources and sinks, rather than for the entire set of taint flow nodes present in the program.\n\nWe first describe what taint flow nodes count as sources and sinks in the program, and then we plug those definitions into the `isSource` and `isSink` predicates. We pass a module containing the two predicates to a parameterized module to guide the `TaintTracking` library to look for those nodes only. Finally, we convert the taint query into a path-problem query to reveal the intermediate steps to take to reach a sink node from a source node.\n\nThe workshop is split into several exercises. Each exercise has a **hint** that describes useful classes and predicates in the CodeQL standard libraries for C/C++. You can explore these in VSCode using the autocomplete suggestions `Ctrl+Space` and the `Go to Definition` command bound to `F12`. Also, these exercises can be completed using the template `.ql` files in the `src/exercises` directory. If you completely ran out of ideas doing a certain exercise, you can consult the solution for it in the `src/solutions` directory.\n","topics":"Introduction"},{"id":"LDF/103/cpp/02-setup-instructions","title":"Setup Instructions","body":"\nBefore we start iterating on our queries, let us setup our development environment of choice. There are two such ones we recommend: GitHub Codespaces and making a local copy, though we strongly prefer the former.\n\n### GitHub Codespaces\n\nThis is the easiest and fastest way to get started!\n\n1. `cd` to `docs/LDF/103/cpp`.\n2. Run `git lfs pull` to get the precompiled database to work on.\n3. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select the followings:\n    - `ldf-103-cpp/test`,\n    - `ldf-103-cpp/examples`,\n    - `ldf-103-cpp/exercises`,\n    - `ldf-103-cpp/solutions`, and\n    - `ldf-103-cpp/examples-test`.\n    - The easiest way of doing it without manually clicking the checkboxes is to type the prefix `ldf-103-cpp` and then click on the checkbox that selects all of the candidates at once.\n4. From the command palette (bound to `Ctrl+Shift+P` or `Cmd+Shift+P`), choose `CodeQL: Choose Database from Archive`.\n5. Choose `dotnet_coreclr_fbe0c77.zip` provided by Git LFS.\n\n### Working Locally\n\n1. Install [Visual Studio Code](https://code.visualstudio.com/).\n2. Install the [CodeQL extension for Visual Studio Code](https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/).\n3. Clone this repository, open it in VSCode, and `cd` to `docs/LDF/103/cpp`.\n4. Run `git lfs pull` to get the precompiled database to work on.\n5. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select the followings:\n    - `ldf-103-cpp/test`,\n    - `ldf-103-cpp/examples`,\n    - `ldf-103-cpp/exercises`,\n    - `ldf-103-cpp/solutions`, and\n    - `ldf-103-cpp/examples-test`.\n    - The easiest way of doing it without manually clicking the checkboxes is to type the prefix `ldf-103-cpp` and then click on the checkbox that selects all of the candidates at once.\n6. From the command palette (bound to `Ctrl+Shift+P` or `Cmd+Shift+P`), choose `CodeQL: Choose Database from Archive`.\n7. Choose `dotnet_coreclr_fbe0c77.zip` provided by Git LFS.\n\n## Documentation Links\n\nIf you get stuck, try searching our documentation and blog posts for help and ideas. Below are a few links to help you get started:\n\n- [Learning CodeQL](https://codeql.github.com/docs/writing-codeql-queries/)\n- [CodeQL Language Guides for C/C++](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n  - [Basic query for C and C++ code](https://codeql.github.com/docs/codeql-language-guides/basic-query-for-cpp-code/)\n  - [CodeQL library for C and C++](https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-cpp/)\n  - [Functions in C and C++](https://codeql.github.com/docs/codeql-language-guides/functions-in-cpp/)\n  - [Analyzing data flow in C and C++](https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-cpp-new/)\n- [CodeQL Standard Library for C/C++](https://codeql.github.com/codeql-standard-libraries/cpp)\n- [Using the CodeQL extension for VSCode](https://codeql.github.com/docs/codeql-for-visual-studio-code/)\n","topics":"Setup Instructions"},{"id":"LDF/103/cpp/03-describing-each-entry-points","title":"Describing Each Entry-points","body":"\n## Exercise 1\n\nBy \"_non-constant_ format strings\", what we really care mean is whether an external attacker can provide it. As a first step, we try to identify elements in the codebase which represent untrusted user input. Use the `SecurityOptions` class provided by `semmle.code.cpp.security.Security` to identify `DataFlow::Node`s whose expressions are considered user input.\n\n<details>\n<summary>Hint</summary>\n\n- The `SecurityOptions` class is a little different from the existing classes we have seen, because it is a _configuration_ class which does not represent any set of particular values in the database. Instead, we use a variable of this type to use its member predicates which are useful for writing security related queries.\n  - For our case it provides a predicate called `isUserInput` which is a set of expressions in the program which are considered user inputs. You can use the `Go to Definition` command bound to `F12`, to see what counts as a user input function.\n- `isUserInput` has two parameters, but we are not interested in the second parameter, so we can just plug it with `_` to ignore it.\n- We want the `DataFlow::Node` for the user input, so remember to use `.asExpr()` to make that compatible with the `isUserInput` API.\n- You can configure custom sources by creating a new subclass of `SecurityOptions`, and overriding one of the existing predicates. However, the default definitions are sufficient for our purposes.\n\n</details>\n\n## Exercise 2\n\nNow we consider our another point of interest: the format strings to formatting functions like `printf`. It would be a good next step to identify what such function calls are and where they are. Find formatting function calls to identify `DataFlow::Node`s whose expressions are considered as a format string to a formatting function call.\n\n<details>\n<summary>Hint</summary>\n\n- We do not need any additional libraries like `semmle.code.security.Security` from the above.\n- The overall approach is exactly the same as the previous exercise.\n\n</details>\n\nBy now, we have identified one end where the data flows start, and another where the flows end.\n","topics":"Describing Each Entry-points"},{"id":"LDF/103/cpp/04-identifying-connected-sources-and-sinks","title":"Identifying Connected Sources and Sinks","body":"\n## Creating a Custom Taint Analysis\n\nWe now know where a user input enters the program, and where format strings are used. What's left is to combine these to find out whether data flows from one of these sources to one of these format strings by looking for what global data flows there are.\n\nAs we mentioned in the introduction, unlike local flows when looking for global data flows we need to specify what sources and sinks we are interested in. We express the flows we aim to find by passing a configuration module to an aptly named module `TaintTracking::Make` which is available by importing `semmle.code.cpp.dataflow.new.TaintTracking`.\n\n`TaintTracking::Make` is a special kind of module in that it is _parameterized_. An ordinary module simply groups different classes and predicates in one scope, whereas a parameterized module needs to be passed predicates or even modules to complete its definition. In the case of `TaintTracking::Make`, it needs a module that contains predicates `isSource` and `isSink`. So, we declare a module with our own definitions of `isSource` and `isSink`, and pass that module to `TaintTracking::Make` to create our own version of `TaintTracking` relevant to our problem.\n\nTherefore, in this workshop we focus on implementing a configuration module along with using the customized `TaintTracking` module. For the configuration module, let us declare one named `TaintConfig` with `isSource` and `isSink`.\n\n```ql\nmodule TaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    /* TBD */\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    /* TBD */\n  }\n}\n```\n\nThen, we pass `TaintConfig` to `TaintTracking::Make`:\n\n```ql\nmodule CustomTaintTracking = TaintTracking::Make<TaintConfig>;\n```\n\nNow, `CustomTaintTracking` is now our version of `TaintTracking` configured to use our definition of isSource and isSink, tailored to our problem of finding possible format string injections. We use the `hasFlow` predicate inside `CustomTaintTracking` to find what flows are there from a source and a sink.\n\nPutting it all together, we get an outline of the query we will write:\n\n```ql\nimport cpp\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.security.Security\n\nmodule CustomTaintTracking = TaintTracking::Make<TaintConfig>;\n\nmodule TaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    /* TBD */\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    /* TBD */\n  }\n}\n\nfrom DataFlow::Node source, DataFlow::Node sink\nwhere CustomTaintTracking::hasFlow(source, sink)\nselect sink.asExpr(), \"This format string may be derived from a $@.\", source.asExpr(),\n  \"user-controlled value\"\n```\n\n## Exercise 3\n\nAt Exercise 1, we have already described the entry-points from which data flows in; we just have to wrap that query into a predicate. Implement the `isSource` predicate in this using the previous query for identifying user input `DataFlow::Node`s.\n\n<details>\n<summary>Hint</summary>\n\n- Use an `exists(..)` to introduce a new variable for `SecurityOptions` within the `isSource` predicate.\n\n</details>\n\n## Exercise 4\n\nWe also described the other entry-points where the data flows out of the program at Exercise 2. Implement the `isSink` predicate to identify format strings of format calls as sinks, in a similar manner as in Exercise 1.\n\n<details>\n<summary>Hint</summary>\n\n- Use an `exists` to introduce a new variable of type `FormattingFunctionCall`, and use the predicate `getFormat()` to identify the format strings.\n- Remember to use `DataFlow::Node.asExpr()` when comparing with the result of `getFormat()`.\n\n</details>\n\nIf we now run the query, we find the `argv` parameter of the `main` function as the source, and an `snprintf` call at `CreateDumpCommon`.\n","topics":"Identifying Connected Sources and Sinks"},{"id":"LDF/103/cpp/05-finding-flows-between-sources-and-sinks","title":"Finding Flows Between Sources and Sinks","body":"\n## Turning the Taint Query into a Path Problem Query\n\nIf we look at the previous results, however, it can be hard to verify whether the results are genuine or not, because we only see the source of the problem and the sink, but not the path in between. This can be achieved by converting the query to a _path problem_ query. After we're done, the CodeQL VSCode extension will now show the intermediate path nodes when we click to unfold a drawer.\n\n### Exercise 5\n\nLet us take the regular `@problem` query we wrote for Exercise 4. How can we lift this into a query for path problem? Convert it to a path problem query.\n\n<details>\n<summary>Hint</summary>\n\n- Convert the `@kind` from `problem` to `path-problem`. This tells the CodeQL toolchain to interpret the results of this query as path results.\n- Add a new import `CustomTaintTracking::PathGraph`, which will report the path data alongside the query results.\n- Change the type of `source` and `sink` variables from `DataFlow::Node` to `CustomTaintTracking::PathNode`, to ensure that the nodes retain path information and they are relevant to our domain of format string injection.\n- Use `hasFlowPath` instead of `hasFlow`.\n- Change the `select` statement to report the `source` and `sink` as the second and third columns. The toolchain combines this data with the path information from `PathGraph` to build the paths.\n\n</details>\n\nNow we should see a path from `argv` to the `snprintf` call, chained together by threading intermediate path nodes!\n","topics":"Finding Flows Between Sources and Sinks"},{"id":"LDF/103/cpp/06-conclusion","title":"Conclusion","body":"\nIn this workshop, we have seen how to reason about global data flows in a C program. We opted for taint flows since \"breaking out\" array elements needed to be taken into account, and for global flows because the format string value passed across function scope boundaries.\n\nFor this, we used the `TaintTracking` library and wrote our own configuration for it. We encapsulated the `where` clause into predicates, `isSource` and `isSink` in a module `CustomTaintTracking`. Also, we learned the concept of modules, parameterized modules, and their uses when it comes to configuring the `TaintTracking` library.\n","topics":"Conclusion"},{"id":"LDF/103/cpp","title":"Dataflow I for C/C++","body":"\n## Introduction\n\nMany security problems, format string injection, can be phrased in terms of _information flow_:\n\n> _Given a (problem-specific) set of sources and sinks, is there a path in the data flow graph from some source to some sink?_\n\nSome real world examples include:\n\n- SQL injection: A user input received outside a program is a source, and the assembled SQL query run against a database is a sink.\n- Reflected XSS: An HTTP request received by a server backend is a source, and an HTTP response containing possibly malicious Javascript code is a sink.\n\nWe can solve such problems using either the data flow library or the taint tracking library. There are two variants of data tracking available in CodeQL:\n\n- Local (\"intra-procedural\") data/taint flow models flow within one function.\n- Global (\"inter-procedural\") data/taint flow models flow across function calls, chained by their arguments.\n\nOn the one hand, local data/taint flow is computed only within a scope of a single function and is feasible to compute for all functions in a CodeQL database, but does not give an interesting result by itself. On the other hand, global data/taint flow allows us to understand how a piece of data might travel through the entire program, hence yields more interesting result.\n\nBut global data/taint flows are not feasible to compute for all functions in a database because the number of paths becomes _exponentially_ larger for global data flow, making infeasible to build a reachability table for the whole program, given any reasonably sized one. That is, constructing the table is bounded by `O(n*n)` where `n` is the number of data flow nodes in the _entire_ program.\n\nThe global data flow (and taint tracking) library avoids this problem by requiring that the query specifies what _sources_ and _sinks_ to look for. This allows CodeQL to compute paths containing only the restricted set of nodes between the specified sources and sinks, rather than for the entire set of data flow nodes present in the program.\n\nIn this workshop we write a global data flow query to find if there is a format string that is supplied by an attacker from outside the program which might travel through several functions. To do this, we will learn the following:\n\n- How to use the `Security` library for predefined entry-point definitions\n- How to use the `TaintTracking` library to specify an analysis\n- How to use the `PathGraph` library to find the full path with intermediate nodes\n","topics":"taint, C++, CPP, global, format-string, coreclr"},{"id":"LDF/103","title":"LDF-103 - Dataflow I","body":"\n## Workshop Description\n\nWe have learned how to query the AST in LDF-101 and how to think about the input program in terms of control flow in LDF-102. Now, reasoning about programs takes on a third dimension: thinking in terms of data flow. Data which flow within a program are represented as paths from a certain set of data-flow nodes to another set of data-flow nodes. These data-flow nodes can roughly be matched to nodes in the AST, which we have learned in LDF-101, but they add more subtleties such as reading or writing to an access path formed against an object variable. Also, they live in a separate graph called data flow graph apart from the other two graphs which are ASTs (abstract syntax trees) and CFGs (control flow graphs).\n\nData flow analysis shines when looking into a program for its security aspects, since a vast majority of security vulnerabilities can be framed as an untrusted data being able to travel through a program, ending up on critical endpoints such as those which render templated HTML, send HTTP requests, or update a production database with an assembled SQL statement. Therefore, CodeQL provides a taint-tracking library (`TaintTracking`) better suited for these queries which propagates untrust towards certain data, as well as providing a more general but basic library (`DataFlow`) that tracks a certain piece of data until it gets modified.\n\nIn these set of courses we learn how to use the two libraries for statically-typed languages such as C/C++, Java, Go, and Swift, as well as dynamically-typed languages such as Python, JavaScript, and Ruby. The latter class of languages depends more on data flow analyses than the former, since they lack static type information to reason about program elements. We will also experience the power and convenience of security-related classes and queries included in the CodeQL standard library.\n","topics":"LDF-103 - Dataflow I"},{"id":"LDF","title":"Language Dependent Features","body":"\n## Overview\n\nThe Language Dependent Features Workshops are a new set of workshops designed to\nprovide participants with a comprehensive understanding of the language-specific\naspects of CodeQL. The workshops cover fundamental concepts such as data-flow\nanalysis, taint tracking, and syntax analysis. These language-dependent aspects\nof CodeQL are essential for understanding how to effectively write code queries\nthat are tailored to specific programming languages. For instance, taint\ntracking is used to identify data that has been modified by an untrusted source\nin web applications. Participants will learn how to use taint tracking to\nimprove the security of web applications written in languages such as PHP,\nJavaScript, and Python.\n\nThe Language Dependent Features Workshops provide participants with a thorough\nunderstanding of the extensions of CodeQL in the form of a standard library\nwritten in the QL language. The standard library provides a set of predefined\npredicates that can be used to query and analyze code in a specific language.\nFor example, in C++, the standard library provides predicates to analyze virtual\nfunctions, class inheritance, and exception handling. In Java, the standard\nlibrary provides predicates to analyze reflection, inner classes, and anonymous\nclasses. By mastering the standard library of a specific language, participants\nwill be able to write more sophisticated queries that leverage the\nlanguage-specific features of CodeQL.\n\nOverall, The Language Dependent Features Workshops are an excellent resource for\ndevelopers looking to gain a comprehensive understanding of CodeQL. By mastering\nlanguage-dependent aspects such as data-flow analysis, taint tracking, and\nsyntax analysis, participants will be able to write more sophisticated queries\nthat can identify complex security vulnerabilities and improve code quality.\nFurthermore, the workshops provide participants with the knowledge needed to\neffectively use the extensions of CodeQL provided by the standard library,\nenabling them to write more powerful queries that can analyze the intricacies of\nspecific programming languages.\n","topics":"Language Dependent Features"},{"id":"QLC/100/01-introduction","title":"Introduction","body":"\nThis workshop provides a tour of CodeQL, discussing the tooling and\nthe QL language.\n","topics":"Introduction"},{"id":"QLC/100/02-setting-up-your-development-environment","title":"Setting up your development environment","body":"\nBefore we start we are going to spend some time to setup the development environment because that is essential for you to participate in the workshop.\n\nThe development environment will consist of:\n\n- [Visual Studio Code](https://code.visualstudio.com/)\n- The [CodeQL](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql) extension\n- The [CodeQL CLI](https://github.com/github/codeql-cli-binaries/releases/latest)\n\nFollow the next steps to set up your environment. Feel free to reach out for support if things aren't going as planned.\n\n1. Ensure you have the latest Visual Studio Code installed by downloading it from the [download page](https://code.visualstudio.com/Download) for your operating system and install it by following the [setup](https://code.visualstudio.com/docs/setup/setup-overview) instructions.\n2. Install the CodeQL extension from the [Extension Marketplace](https://code.visualstudio.com/docs/editor/extension-marketplace).\n\nThe CodeQL extension automatically installs and updates the CodeQL CLI. However, the extension managed CLI is inconvienient to use directly in a Visual Studio Code terminal or other terminal available on your system due to the isolation mechanisms applied to Visual Studio Code extensions. We want to directly use the CodeQL CLI for the tasks that haven't been made available through the CodeQL extension, such as create QL packs and building databases. No worries if that doesn't ring a bell yet. These topics will be discussed in this workshop.\n\nTo install the CodeQL CLI and configure the Visual Studio Code extension use the following steps. We have split up the instructions for those that have the [GitHub CLI](https://cli.github.com/) installed and [authenticated](https://cli.github.com/manual/gh_auth_login) and for those who don't.\n\n1. Install the CodeQL CLI with the GitHub CLI (GH)\n\n    For those that have GH you can install the CodeQL extension to manage CodeQL CLI installations:\n\n    ```bash\n    # Install the CodeQL extension\n    gh install codeql\n\n    # Install a CodeQL stub for use with the Visual Studio Code extension. Default directory is /usr/local/bin.\n    # For convenience, make sure the chosen path is added to your path environment variable.\n    # For Linux and MacOS, add it to the $PATH environment variable.\n    # For Windows, add it to the %PATH% environment variable.\n    gh codeql install-stub\n\n    # Install the latest version\n    gh codeql set-version latest\n    ```\n\n2. Install the CodeQL CLI manually\n\n    To manually install the latest CodeQL CLI download the archive corresponding to your operating system from the [release](https://github.com/github/codeql-cli-binaries/releases/latest) page. Unzip the archive to a location of choice, then make sure that location is added to your path environment variable. For Linux and MacOS, add it to the `$PATH` environment variable. For Windows, add it to the `%PATH%` environment variable.\n\n3. Verifying your CodeQL CLI setup\n\n    The CodeQL CLI has subcommands that can help with verify that the CLI is correctly set up.\n\n    Run the following command to show which languages are available for database creation.\n\n    ```bash\n    codeql resolve languages\n    ```\n\n    For the purpose of this workshop make sure that the `cpp` language is available.\n\n4. Configuring the CodeQL extension\n\n    With the CodeQL CLI installed we are going to configure the CodeQL extension to use the installed extension.\n\n    Locate the setting `codeQL.cli.executablePath` in the [user and workspace settings](https://code.visualstudio.com/docs/getstarted/settings) and update it to the absolute path of the CodeQL CLI executable if is not part of your system's path environment or just `codeql` (`codeql.exe` for Windows). The extension will notify you of any problems in case of a misconfiguration.\n","topics":"Setting up your development environment"},{"id":"QLC/100/03-preparing-your-first-ql-query","title":"Preparing your first QL query","body":"\nWith the development environment set up we can start with writing your first\nquery. For this workshop, you will need to clone the repository `https://github.com/codeql-workshops/codeql-learning-catalog` and save your work in the\n`docs/QLC/100/src/problems` directory.\n\n```bash\ngit clone https://github.com/codeql-workshops/codeql-learning-catalog\n```\n\nAfter cloning the repository open the folder in Visual Studio Code.\n\nBefore we can write our actual query we need to create a [CodeQL pack](https://codeql.github.com/docs/codeql-cli/creating-and-working-with-codeql-packs/). A CodeQL pack is a unit of queries or libraries that can be shared. CodeQL pack also provides the necessary information to CodeQL to run a query part of that pack.\n\nLet's start with switching to the workshop directory to store our the workshop assets.\n\nIn Visual Studio Code, open the [integrated terminal](https://code.visualstudio.com/docs/terminal/basics) and run the following commands to create a CodeQL pack.\n\n```bash\ncd docs/QLC/100/\ncodeql pack init qlc-100/problems -d src\n```\n\nThis will create a subdirectory of `src` named `qlc-100/problems` which will contain the file `qlpack.yml` with the following contents:\n\n```yaml\n---\nlibrary: false\nname: qlc-100/problems\nversion: 0.0.1\n```\n\nThe `qlpack.yml` describes the metadata of a CodeQL pack through properties. A description of the properties can be found [here](https://codeql.github.com/docs/codeql-cli/about-codeql-packs/#qlpack-yml-properties). For now we start with this minimal CodeQL pack specification that states it is a query pack, as opposed to a library pack, via the key `library: false`. The difference will be become apparent when you publish a package. A query pack, when published, will include all its dependencies and a precompiled version of the queries to ensure a fast deployment and evaluation.\n\nWith the query pack set up we are going to create another query pack to hold our tests. CodeQL provides testing infrastructure to create system agnostic unit tests for your queries. System agnostic means that it will not depend on external dependencies and that the tests will provide the same results on different operating systems with different compilers/interpreters and libraries installed.\n\n```bash\ncodeql pack init --extractor cpp qlc-100-tests/problems -d tests\n```\n\nThis will generate a file (`qlpack.yml`), similar what we have seen before, with an additional property `extractor` set to the value `cpp`. Normally the target language is specified by the database, because a database can only target a single language. With the `extractor` property we inform the testing infrastructure to use the C/C++ extractor to create test databases to validate our queries.\n\nTo test a query in the `qlc-100/problems` CodeQL pack we need to inform the `qlc-100-tests/problems` CodeQL pack how to resolve that query. This can be achieved through the `dependencies` property.\n\nChange the `qlpack.yml` to match the following contents.\n\n```yaml\n---\nlibrary: false\nname: qlc-100-tests/problems\nversion: 0.0.1\nextractor: cpp\ndependencies:\n  \"qlc-100/problems\": \"*\"\n```\n\nA dependency is resolved by the CodeQL pack name and a version. While our query CodeQL pack has version `0.0.1` we specify the `*` value to direct the CodeQL package manager to consider a local version of the query pack before reaching out to the package registry to download the latest version.\n\nWith our query and test CodeQL pack up and running we can run the command `codeql pack ls` to list the CodeQL packs that the CodeQL CLI can resolve.\n\n```bash\n▶ codeql pack ls\nRunning on packs: qlc-100-tests/solutions, qlc-100/solutions.\nFound qlc-100/solutions@0.0.1\nFound qlc-100-tests/solutions@0.0.1\n```\n\nThe command doesn't list our just created problem packs. The\n`codeql-workspace.yml` files helps the CodeQL CLI resolve CodeQL packs when\nmultiple are defined in a project.\n\nOpen the file `codeql-workspace.yml` in `docs/QLC/100` and ensure it has the\nfollowing content by adding the item `\"*/problems/qlpack.yml\"`:\n\n```yaml\nprovide:\n  - \"*/solutions/qlpack.yml\"\n  - \"*/problems/qlpack.yml\"\n```\n\nWith the CodeQL workspace re-running the `codeql pack ls` command succeeds.\n\n```bash\n▶ codeql pack ls\nRunning on packs: qlc-100-tests/problems, qlc-100/problems, qlc-100-tests/solutions, qlc-100/solutions.\nFound qlc-100/problems@0.0.1\nFound qlc-100-tests/problems@0.0.1\nFound qlc-100/solutions@0.0.1\nFound qlc-100-tests/solutions@0.0.1\n```\n\nThe `provide` key holds an array of path patterns for CodeQL pack files (i.e., `qlpack.yml` files) that this directory provides. A CodeQL workspace can be considered a container for multiple CodeQL packs. Path patterns allow lightweight globbing where each path component can be a `*`: matching any path component, or `**`: matching multiple arbitrary path components. The latter is useful if your projects contains multiple CodeQL packs organized per category, for example per language. Then the CodeQL workspace file can contain a path pattern per category. For example:\n\n```yaml\nprovide:\n  - \"cpp/**/qlpack.yml\"\n  - \"java/**/qlpack.yml\"\n```\n\ncan be used for the directory tree:\n\n```yaml\n- cpp /\n  - github\n    - security-queries\n  qlpack.yml\n    - security-tests\n  qlpack.yml\n    - security-libs\n  qlpack.yml\n- java /\n  - github\n    - security-queries\n  qlpack.yml\n    - security-tests\n  qlpack.yml\n    - security-libs\n  qlpack.yml\n```\n","topics":"Preparing your first QL query"},{"id":"QLC/100/04-writing-your-first-query","title":"Writing your first QL query","body":"\nNow that we have created our query and test CodeQL packs we can finally start with our first query!\n\nCreate the file `HelloWorld.ql` in the `qlc-100/problems` CodeQL pack with the following content:\n\n```c file=./src/solutions/HelloWorld.ql\n```\n\nThat is it for our first query. To determine if it works as intended we want to test it so we should add a unit test to our `qlc-100-tests/problems` CodeQL pack.\n\n1. Create a folder `HelloWorld` in the `qlc-100-tests/problems` directory.\n2. Add the file `HelloWorld.qlref` in the just created directory `HelloWorld` with the contents:\n\n    ```c file=./tests/solutions/HelloWorld.qlref\n    ```\n\n3. Add the file `HelloWorld.expected` in the just created directory `HelloWorld` with the contents:\n\n    ```c file=./tests/solutions/HelloWorld.expected\n    ```\n\nThe `HelloWorld.qlref` is a query reference file that references to a query to be tested. It is a path relative to a CodeQL pack.\n\n<details><summary>How does CodeQL know which CodeQL pack?</summary>\n\nCodeQL will go through the dependencies to determine which CodeQL pack contains the query.\n\n</details>\n\nInstead of a query reference file you can also specify a query file directly. However, it is common to separate them into their own CodeQL packs so they can be independently be published and deployed.\n\nThe `HelloWorld.expected` file contains the expected output when running the query on a database built from files residing in the `HelloWorld` directory. In our case we have none, so the database will be empty.\n\nWith the qlpack specification for the test we can run the test using the [Test Explorer UI](https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-test-explorer) extension that is installed as a dependency of the CodeQL extension.\n\n![img](/assets/images/QLC/100/test-explorer-ui-extension.png \"The HelloWorld test listed in the Test Explorer UI\")\n\nWe can run the test from the Test Explorer UI or run the test from the terminal with the command:\n\n```bash\ncodeql test run tests/problems/HelloWorld\n```\n\nEither way, running the test will result in the error:\n\n```bash\nError: Could not locate a dbscheme to compile against.\nYou probably need to specify a libraryPathDependencies list in\n/.../src/qlpack.yml\n```\n\nThe test is unable to determine the database schema to our query in the `qlc-100/problems` CodeQL pack. Every CodeQL database adheres to a language specific database schema and every query should adhere to the same schema so it can correctly query the database. The database schema for queries (as supposed to the extractor creating the database) is located in the standard library `all` pack of the language we want to query.\n\nWhile we remain language agnostic with the queries discussed in this workshop, we still need to pick a language for the database schema. Adjust the `qlpack.yml` of the `qlc-100/problems` CodeQL pack to match the following content:\n\n```yaml\n---\nlibrary: false\nname: qlc-100/problems\nversion: 0.0.1\ndependencies:\n  \"codeql/cpp-all\": \"*\"\n```\n\nTo ensure the dependency is available we need to run the command:\n\n```bash\n▶ codeql pack install qlc-100/problems\nDependencies resolved. Installing packages...\nInstall location: /.../.codeql/packages\nPackage install location: /.../.codeql/packages\nAlready installed codeql/cpp-all@0.4.3 (library)\n```\n\nThrough the `qlc-100/problems` CodeQL pack the `qlc-100-tests/problems` CodeQL pack has a dependency on `codeql/cpp-all` as well. So we need to resolve those dependencies by running the command:\n\n```bash\n▶ codeql pack install qlc-100-tests/problems\nDependencies resolved. Installing packages...\nInstall location: /.../.codeql/packages\nPackage install location: /.../.codeql/packages\nAlready installed codeql/cpp-all@0.4.3 (library)\n```\n\nWith all the dependencies resolved we can re-run the test. Try running both from Testing Explorer UI and using the CodeQL CLI.\n\nCongrats, you have written your first query!\n","topics":"Writing your first QL query"},{"id":"QLC/100/05-the-structure-of-ql-query","title":"The structure of a QL query","body":"\nOur first query didn't provide a lot of information around the structure of a QL query besides the use of the `select` keyword.\n\nA typical query contains the following elements:\n\n- Query metadata.\n- Import statements\n- Definitions of classes and predicates\n- The `from`, `where`, and `select` clause.\n\nLet start exploring these components from the bottom up.\n\n1. The `select` clause\n\n    For those familiar with query languages such as SQL the syntax of the `select` clause, consisting of the two optional `from` and `where` parts and the mandatory `select` part, should look familiar.\n\n    ```ql\n    from ...\n    where ...\n    select ...\n    ```\n\n    The `from` part can be used to declare variables. Each variable represents a set of values of the same sort described by the variable's type. Because sets of values can overlap (that is, their intersection is not empty) it can be the case that values have multiple types.\n\n    <details><summary>Can you think of an example of a value in a program that would be described by multiple types?</summary>\n\n    For example, a type representing all the expressions in a program and a type representing all the arithmetic expressions in a program.\n\n    </details>\n\n    The following examples describe types and the values they represent.\n\n    - The primitive type `int` with each value being a 32-bit two's complement integer.\n    - The primitive type `string` with each value being a finite sequence of 16-bit characters, each interpreted as a Unicode code point.\n    - The class `Expr` with each value being an expression in a program (part of the database being queried).\n\n    Note that in the last example we used the term *class* instead of *type*. In QL you can define your own *type* by defining a *class*.\n\n    To reason about the variables and their values we can further restrict the values of the variables in the `where` part.\n\n    QL is a *logic programming language* and is built up of logical formulas. In the `where` part we can use formulas to define logical relations between expressions and are of the form `<expr> <op> <expr>`. Wait, didn't we discussed variables instead of expressions?\n\n    [Expressions](https://codeql.github.com/docs/ql-language-reference/expressions/) evaluate to a set of values.\n\n    <details><summary>What determines the set of values?</summary>\n\n    The set of values an expression evaluates to is determined by a type.\n\n    </details>\n\n    During query writing we will get introduced to the many kinds of expressions. For now we will continue with variables. In a formula a variable can be referenced using a *[variable reference](https://codeql.github.com/docs/ql-language-reference/expressions/#variable-references)*.\n\n    Finally, we have the [select clause](https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses) that determines what we want to *select* as a result for the query. The result of a query will be a set of ordered tuples commonly represented as a table with columns and rows. The columns are determined by the expression provided to the `select` clause. The provided *expressions* **must** evaluate to a value part of a *primitive type*. We will discuss what *primitive types* later on in this workshop. Classes have a *member predicate* `toString` that is used to convert them to a `string`.\n\n    The `as` keyword can be used to label to a column of results and allows the result to be referenced in other expressions part of the select clause. The `order by` keyword allows you to sort the result set. To control the ordering you can use the keywords `asc`, for ascending, and `desc` for descending.\n\n    Let's have a look at some concrete examples!\n\n    1. Add the query `FromWhereSelect.ql` to the CodeQL pack `qlc-100/problems` with the following contents\n\n        ```ql file=./src/solutions/FromWhereSelect.ql\n        ```\n\n    2. Add a directory `FromWhereSelect` with the files `FromWhereSelect.qlref` and `FromWhereSelect.expected` to the CodeQL pack `qlc-100-tests/problems`. Make sure to add the path `FromWhereSelect.ql`, the path to the query relative to the CodeQL pack it belongs to, in the `FromWhereSelect.qlref` file.\n\n    3. Run the newly created QL test.\n\n    The test will fail and output the following result.\n\n    ```diff file=./tests/solutions/FromWhereSelect.expected\n    ```\n\n    <details><summary>Why did the test fail?</summary>\n\n    The output of the query didn't match our test's expected file.\n\n    </details>\n\n    For each test that fails, the CodeQL extension keeps the database so we can investigate why the test failed. In the directory `FromWhereSelect` there should be an additional directory named `FromWhereSelect.testproj`. You can mount the test database with the command `CodeQL: Set Current Database` that is available in the context menu when you right click on the directory `FromWhereSelect.testproj` in the Visual Studio Code file explorer.\n\n    ![img](/assets/images/QLC/100/mount-testproj.png \"Select the failed test database as the current database.\")\n\n    To investigate a failed test you can make use of the `CodeQL: Quick query` functionality. This allows you to quickly create a one-off query for a mounted database.\n\n    To test this, perform the following steps:\n\n    1. Mount the `FromWhereSelect.testproj` database.\n    2. Execute the command `CodeQL: Quick Query` using the Visual Studio Code [Command Palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette). Answer with Yes when prompted to reload the workspace as a multi-folder workspace, and yes when prompted to trust the workspace.\n\n    In the Visual Studio Code Explorer you can now find a new folder named `Quick Queries` with, among others, a file `quick-query.ql` with the contents\n\n    ```ql\n    import cpp\n\n    select \"\"\n    ```\n\n    ![img](/assets/images/QLC/100/quick-query-folder.png \"Quick query folder added to the workspace\")\n\n    The contents of the `quick-query.ql` file has been setup to match the language of your selected database. The language can also be seen in the database section of the CodeQL extension.\n\n    ![img](/assets/images/QLC/100/codeql-databases-section.png \"CodeQL extension databases section\")\n\n    The query can be executed using the command `CodeQL: Run Query` via the Command Palette or the right-click menu.\n\n    Once you have established why the test cased failed, and corrected your query you can re-run the test. If you start with an empty `FromWhereSelect.expected` file you can accept the test output via the right-click menu that is available on the test or run the CodeQL CLI command `codeql test accept tests/problems/FromWhereSelect/FromWhereSelect.qlref`.\n\n    ![img](/assets/images/QLC/100/accept-test-output.png \"Accept test output\")\n\n2. Imports\n\n    QL supports [modules](https://codeql.github.com/docs/ql-language-reference/modules/#modules) to organize and reuse QL code. Each query file, with the extension `.ql`, and library file, with the extension `.qll`, *implicitly* defines a module. The `import` statement can be used to import public names (i..e, not annotated [private](https://codeql.github.com/docs/ql-language-reference/annotations/#private)), of a library module, into the namespace of the current module containing the `import` statement.\n\n    By convention the first statement in a query module is the import of the language library you are targeting. For example, `import cpp`.\n\n    Modules will not be further discussed in this quick-start.\n\n3. Query metadata\n\n    A query has properties that provide information to users of a query and provides information to consumer of the query result on how to display its results. These properties are known as query metadata.\n\n    The query metadata resides at the top in a query file as a [QLDoc comment](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#qldoc-qldoc). A QLDoc comment starts with a `/**`, ends with a `*/`, and can span multiple lines. The body of QLDoc, the *contents*, is compromised of all the text surrounded by~/\\*\\*~ and `*/`. For each line the leading whitespace followed by a `*` is ignored and excluded from the content. The [contents](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#content) is interpreted as [CommonMark](https://commonmark.org/). The properties of a query are specified as tags. A tag is started with a `@` sign followed by any number of non-whitespace characters to form the *key* of the tag. A single whitespace character separates the key from the value, with the value being the remainder of the line.\n\n    The supported properties of a query can be found [here.](https://codeql.github.com/docs/writing-codeql-queries/metadata-for-codeql-queries/#metadata-properties) The next snippet shows the metadata for a standard library query.\n\n    ```ql\n    /**\n    * @name Uncontrolled data used in OS command\n    * @description Using user-supplied data in an OS command, without\n    *              neutralizing special elements, can make code vulnerable\n    *              to command injection.\n    * @kind path-problem\n    * @problem.severity error\n    * @security-severity 9.8\n    * @precision high\n    * @id cpp/command-line-injection\n    * @tags security\n    *       external/cwe/cwe-078\n    *       external/cwe/cwe-088\n    */\n    ```\n\n    Here are a few takeaways for query metadata when consuming the results in GitHub Code Scanning:\n\n    - A `@name` property is **required** and defines a display name for the query. The [metadata style guide](https://github.com/github/codeql/blob/master/docs/query-metadata-style-guide.md#query-name-name) prescribes you should use sentence capitalization without a full stop.\n    - A `@description` property is **required** and defines a short help message. The [meta data style guide](https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md#query-descriptions-description) prescribes you should be written as a sentence or a short paragraph with sentence capitalization and a full stop.\n    - A `@id` property is **required**. The id must uniquely identify a query and *should* follow the CodeQL convention by starting the id with a *language code* followed by a `/`. The remainder of the id should consists of a short noun phrase. For example, `cpp/command-line-injection`. Additional terms can be added to group queries. For example, `js/angular-js/missing-explicit-injection` and `js/angular-js/dpulicate-dependency`. **Note: Code Scanning uses the id to track alerts, changing the id will result in alerts tracked with the old id being closed and new alerts with the new id being introduced.**\n    - A `@kind` property is **required**. There are multiple query types, but the most common alert kinds are: `problem` and `path-problem`. The kind property determines how to display the result of a query and expects a specific `select` form described in [Defining the results of a query](https://codeql.github.com/docs/writing-codeql-queries/defining-the-results-of-a-query/) and [Creating path queries](https://codeql.github.com/docs/writing-codeql-queries/creating-path-queries/#creating-path-queries).\n    - A `@precision` property is *optional* for alert queries and indicates the proportion of true positives expected for the query. Possible values are:\n        - `low`, expect a lot of false positives\n        - `medium`, expect a moderate number of false positives\n        - `high`, expect a low number of false positives\n        - `very-high`, expect false positives in exceptional cases\n    - A `@problem.severity` property is *optional* for alert queries and indicates the severity for alerts. Possible values are:\n        - `error`, an issue that likely results in incorrect program behavior such as a crash or vulnerability\n        - `warning`, an issue indicating a potential problem and could become a problem due to changes in the code.\n        - `recommendation`, an issue that indicates code behaves correctly, but could be improved.\n    - A `@tags` property is *optional*. Tags can be used to group queries into categories for identification purposes. The common tags are: `correctness`, `maintainabilility`, `readability`, `security`. Other known uses cases are to tag a query with a known weakness classification such as a [CWE](https://cwe.mitre.org/) or [OWASP Top 10](https://owasp.org/Top10/). Our standard queries, for example, use a CWE tag like `external/cwe/cwe-119`.\n        - An additional `@security-severity` property is available for queries with `security` tag. This defines a severity with the range `0.0` - `10.0`. The blog [CodeQL code scanning: new severity levels for security alerts](https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/) describes how to compute a severity.\n\n    The query properties can be used to filter which queries are part of a [CodeQL query suite](https://codeql.github.com/docs/codeql-cli/creating-codeql-query-suites/#filtering-the-queries-in-a-query-suite). This won't be discussed in this quick-start.\n","topics":"The structure of a QL query"},{"id":"QLC/100/06-the-essence-of-a-ql-query","title":"The essence of a QL query","body":"\nWith a basic understanding of the structure of a query we can continue looking at the building blocks of queries, namely *types*, *expressions*, *formulas*, and *predicates*.\n\nIn essence, a query is about relating types and their values. By solving a logic puzzle we are going to learn more about the building blocks and how they can be used.\n\n### Predicates\n\nLet's start with a simple logic puzzle. There are five racers named `A`, `B`, `C`, `D`, and `E`. Each finish the race as follows:\n\n- `C` finishes before `B`, but not before `D`\n- `E` finishes before `A`, but not before `B`\n\nWhat is the finish order?\n\nWe have a relation between racers that determines who finishes before another racer. How can we capture such a relation?\n\nLet's start with a first attempt where we use integers combined with comparison expressions. Create the query file `PuzzleOneAttemptOne.ql` and the corresponding QL test files in the directory `PuzzleOne`.\n\n```ql file=./src/solutions/PuzzleOneAttemptOne.ql\n```\n\nWhen we run this query we get the following results.\n\n```diff file=./tests/solutions/PuzzleOneAttemptOne.expected\n```\n\nRepresenting the correct result `D` `C` `B` `E` `A`.\n\nHowever, the query doesn't seem very *elegant*. We have to manually construct the final result. What if we add more racers, lets say up to a total of 1024? That would become very unwieldy. We need a better way to capture the relation between two racers.\n\nIn logic, a *predicate* represents a property or relation. QL, being a logical language, supports predicates. Create the query file `PuzzleOneAttemptTwo.ql` and the corresponding QL test files. In the query file define the predicate `finishesBefore` that captures the relation between the racers.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoA.ql\n```\n\nRun the `PuzzleOneAttemptTwo.qlref` test and mount the test database `PuzzleOne.testproj` of the failed test. Note that the test database has the name of the test directory, because the parent directory of each `.qlref` file is used to construct a test database.\n\nWith the test database mounted we can now test our predicate `finishesBefore` with quick evaluation. The Visual Studio Code editor will provide hints as to what can be quick evaluated.\n\n![img](/assets/images/QLC/100/quick-evaluation.png \"Quick evaluating hint on `finishesBefore` predicate.\")\n\nThe result of quick evaluating the `finishesBefore` predicate should match:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwoA.expected\n```\n\nThe quick evaluation functionality is super useful when debugging your logic. Besides the hints provided by Visual Studio Code you can also select *formulas*, *expressions*, and *types* and quick evaluate them with a right-click to access the `CodeQL: Quick Evaluation` command.\n\n![img](/assets/images/QLC/100/partial-quick-evaluation.png \"Quick evaluating the first two disjunctions.\")\n\nTo find the finish order we want to *connect* the tuples created by the predicate `finishesBefore`. For example, `(D, C)` and `(C, B)` to get a partial finish order `(D,C,B)`. That is, the second argument in one predicate call becomes the first argument in another call.\n\n<details><summary>Implement a query to find the partial finish order `D C B` using the `finishesBefore` predicate.</summary>\n\n```ql\nfrom string one, string two, string three\nwhere one = \"D\" and finishesBefore(one, two) and finishesBefore(two, three)\nselect one, two, three\n```\n\n</details>\n\nThe solution works well for this partial finish order, but we are back to representing each of the racers as a variable and having to make multiple predicate calls to get the complete finish order.\n\nThis repeated connecting of predicate calls is a common pattern in reachability problems and are typically concerned with whether one location can reach another location given a step function. More concrete examples are:\n\n- Can function `foo` reach function `bar` through function calls?\n- Can the value of variable `foo` reach argument `bar` of function `baz`?\n\nWe can treat the finish order problem as a reachability problem by finding the path from the first finisher to the last.\n\nQL supports the repeated application of a predicate through recursion. In a recursive predicate we have to consider two cases:\n\n1. The base case, which determines when we are done.\n2. The recursive case\n\nThe following example demonstrates how recursion can be used to find all the finishers after a certain finisher. Note that we renamed the predicate `finishesBefore` to `finishesBeforeStep` to highlight it is a step function.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoB.ql#L1-L17\n\n```\n\nThe base case is our step predicate `finishesBeforeStep`, finding all the finishers reachable with a single step. The recursive case uses the [quantified formula](https://codeql.github.com/docs/ql-language-reference/formulas/#quantified-formulas) [exists](https://codeql.github.com/docs/ql-language-reference/formulas/#exists). Quantified formulas allow us to introduce temporary variables that we can use in the formula's body to create new formulas from existing ones. The `exists` formula has the syntax `exists(<variable declarations> | <formula>)`. The syntax used in our example, `exists(<variable declarations> | <formula1> | <formula2>)`, is equivalent to `exists(<variable declarations> | <formula1> and <formula2>)`.\n\nWe use the `exists` to create a new formula from the predicate `finishesBeforeStep` and the predicate `finishesBefore` to find another racer that we can reach with a single step and all the racers that reachable from that other racer.\n\nQuick evaluating the new `finishesBefore` predicate provides us with the result:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwoB.expected\n```\n\nBecause this type of recursion is very common QL has implemented a shortcut that computes a [transitive closure](https://codeql.github.com/docs/ql-language-reference/recursion/#transitive-closures) of a predicate. The transitive closure is obtained by repeatedly calling a predicate.\n\nQL has two types of transitive closures. The transitive closure `+` that calls a predicate one ore more times. The reflexive transitive closure `*` calls a predicate zero or more times. The transitive closure of a predicate call can be used by appending a `+` or a `*` to the predicate name in a predicate call.\n\nUsing our step function we can compute the transitive closure by calling it as `finishesBeforeStep+(racerOne, racerTwo)`.\n\nThe transitive closure cannot be used on all predicate calls. The predicate must have two arguments with types that are [compatible](https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility).\n\n<details><summary>Write a query that uses the transitive closure of the predicate `finishesBeforeStep` to compute the same results as the recursive predicate `finishesBefore`.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoC.ql#L11-L14\n\n```\n\n</details>\n\nTo determine if the results are the same you can use the `Compare Results` option in the `Query History` pane of the CodeQL extension.\n\nSelect to last two items in the history, right-click, and select `Compare Results`. This should result in an empty comparison.\n\n![img](/assets/images/QLC/100/compare-results.png \"Compare query results\")\n\nWith our transitive closure we are almost done with finding the finish order. First we want to limit the reachable racers from the first finisher. Secondly we want a single answer.\n\nLet's continue with determining which racer is the first to finish.\n\n<details><summary>How can you determine who is the first finisher?</summary>\n\nThe first finisher is a finisher with no finisher before them. That is, it is not the case there exists another finisher that finishes before the first one.\n\n</details>\n\nIn QL you can negate a formula by prepending a `not` to that formula. For example, the following query returns all pairs where `racerOne` does not finish before `racerTwo`.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoD.ql#L11-L16\n```\n\nThe extra equality expressions for `racerOne` and `racerTwo` are required because we can't determine the range of values for `racerOne` and `racerTwo` from a negation. That is, `not` is not [binding](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding). Without those the CodeQL will give an error that `racerOne` and `racerTwo` are not bounded to a value. This is caused by the fact that many of the primitive types including `string` are infinite. They have an infinite number of values. Since QL can only work with finite results we need to restrict the set of values for the result. Before, that was done by the `finishesBeforeStep` predicate.\n\nTo restrict the set of values we use the member predicate `charAt` that expects an index. We, however, are not interested in a particular index so we pass the [dont'-care expression](https://codeql.github.com/docs/ql-language-reference/expressions/#don-t-care-expressions). That is any value which will result in calling the predicate with all the indices binding the racers to the characters `[\"A\", \"B\", \"C\", \"D\", \"E\"]`. `racerOne = \"ABCDE\".charAt(_)` is equivalent to `racerOne = [\"A\", \"B\", \"C\", \"D\", \"E\"]` where the latter is the [set literal expression](https://codeql.github.com/docs/ql-language-reference/expressions/#set-literal-expressions) we used in the very beginning.\n\n<details><summary>Using the `not` formula, write a predicate `firstFinisher` that holds if a finisher is the first finisher. Remember, `not` is not [binding](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding).</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoE.ql#L11-L14\n```\n\n</details>\n\nWith the `firstFinisher` predicate we can now limit the results to the first finisher and all those that are reachable from the first finisher.\n\n<details><summary>Write a query that returns the first finisher and all the finisher reachable from that first finisher.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoF.ql#L16-L18\n```\n\n</details>\n\nSo now we have the first finisher and all those that finish after. However, there are still multiple results. The last task is to [aggregate](https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations) the finishers to get the final finish order.\n\nIn our case the aggregate `[[https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations][concat]]` looks interesting, however, we can't properly control the order of the results which in this case is important.\n\nThat is, the following does not give the correct order because strings are sorted lexicographically.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoG.ql#L16-L20\n```\n\n<details><summary>Why does the query use the reflexive transitive closure operator `*`?</summary>\n\nTo include the `firstFinisher` that does not have a finisher before them.\n\n</details>\n\nThat means we need to build the final finish order ourselves, recursively. We have seen recursion and the closely related transitive closure before. In most cases the transitive closure is sufficient, but sometimes you want more control. For example when the goal is to find all the functions reachable from a function `entrypoint` that are not reachable by an authorization function to determine authentication bypasses.\n\nIn this case we want to build up the finish order from the first finisher. A recursive problem requires two cases, the base case, and the recursive case.\n\n<details><summary>The base case determines when we are done. What would that be in our problem?</summary>\n\nWhen we have reached the last finisher.\n\n</details>\n\n<details><summary>Implement the predicate `lastFinisher` using the already defined predicate `finishesBeforeStep`. You can take inspiration from the predicate `firstFinisher`. Remember that the `not` does not *bind*.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoH.ql#L16-L18\npredicate lastFinisher(string racer) {\n    not finishesBeforeStep(racer, _) and finishesBeforeStep(_, racer)\n}\n```\n\n</details>\n\n<details><summary>Write the predicate `finishOrderFor`. QL supports [predicates with results](https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-with-result). A predicate with a result is defined by replacing the keyword `predicate` with the type of the result. The result can be referenced through a special variable `result`. Semantically it is the same as predicates without a result, the result would just be a parameter, but it can result in a more readable query because you can omit a `exists`.\n\n```ql\nstring finishOrderFor(string racer) {\n    none() // replace with implementation\n}\n```\n\n</summary>\n\nWith the predicate `finishesBeforeStep` rewritten as a predicate with a value, and the predicate `finishOrderFor` written as a predicate with a value, the complete query becomes.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwo.ql\n```\n\nThe result of this query should be:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwo.expected\n```\n\n</details>\n","topics":"The essence of a QL query"},{"id":"QLC/100/07-conclusion","title":"Conclusion","body":"\nIn this quickstart we have:\n\n- setup a development environment,\n- looked at CodeQL packs for queries and tests,\n- learned about the structure of a query, and\n- used predicates to solve a logic puzzle.\n","topics":"Conclusion"},{"id":"QLC/100","title":"QLC 100 - QL Quickstart","body":"\n## Introduction\n\nThe QL Quickstart workshop is designed to provide participants with a\ncomprehensive introduction to the QL language used in CodeQL, with a focus on\nthe basics of setting up a development environment and writing QL queries. The\nworkshop covers several key topics, including setting up your development\nenvironment for CodeQL development, preparing to write your first QL query,\nwriting your first QL query, the structure of a QL query, and the essence of a\nQL query.\n\nDuring the first section of the workshop, participants will learn how to set up\ntheir development environment for CodeQL development. They will learn how to\ndownload and install CodeQL tools and set up their environment to work with the\nCodeQL query language. They will also learn about the basics of using CodeQL in\nthe context of a development environment, including how to navigate the\ninterface and run queries.\n\nIn the second section, participants will learn about the basics of preparing to\nwrite their first QL query. They will learn about the different types of queries\nthat can be used in CodeQL, including database queries, code queries, and result\nset queries. They will also learn about the structure of a QL query and the\ndifferent components that make up a query.\n\nIn the third section, participants will learn how to write their first QL query.\nThey will learn about the essence of a QL query and how to structure their code\nto achieve the desired results. They will also learn how to debug their code and\ntroubleshoot common errors that can arise when working with CodeQL. By the end\nof the workshop, participants will have a solid foundation in the QL language\nand will ready to study subsequent topics about the QL language.\n","topics":"QLC 100 - QL Quickstart"},{"id":"QLC","title":"QL Core","body":"\n## Overview\n\nThe QL language used in the CodeQL analysis platform is a domain-specific\nprogramming language that includes several powerful features that make it\nwell-suited for security analysis. Some of the key features of QL include\nclasses, predicates, modules, recursion, and types.\n\nClasses in QL allow programmers to define and group related data and methods\ntogether. This makes it easy to organize and manipulate data in a codebase.\nPredicates are another important feature of QL that allow programmers to define\nreusable queries for analyzing code. Predicates are similar to functions in\nother programming languages and can be called from other queries or predicates\nto build complex analysis pipelines.\n\nModules in QL provide a way to organize code and separate concerns. They allow\nprogrammers to break a large analysis task into smaller, more manageable pieces\nthat can be developed independently. Recursion is another powerful feature of QL\nthat allows queries to call themselves repeatedly until a condition is met. This\nmakes it possible to analyze complex control flow and data flow patterns in\ncode.\n\nFinally, QL includes a rich type system that allows programmers to define and\nuse complex data types in their queries. This makes it possible to model complex\ndata structures and analyze them in a meaningful way.\n\nThe QL Core workshops are designed to provide participants with a comprehensive\nunderstanding of these other features of QL. Participants will learn how to use\nthese concepts to write effective queries for identifying security\nvulnerabilities in code. By the end of the workshops, participants will be able\nto use these features to write complex queries that can analyze even the most\nchallenging codebases.\n","topics":"QL Core"}]