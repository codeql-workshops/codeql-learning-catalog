export const posts = [{"id":"docs/LDF/101/cpp/01-introduction","title":"Introduction","body":"\n## Introduction\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\nincididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat\nblandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque\nviverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus\ndictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis\nlectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus\nfeugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra\nvitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et\nsollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum\nat varius vel.\n\n```c file=./src/solutions/example1-1.ql#L2-L5\ntest\n```\n","topics":"Introduction"},{"id":"docs/LDF/101/cpp/02-a-whirlwind-tour-of-codeql","body":""},{"id":"docs/LDF/101/cpp/03-setting-up-your-environment","body":""},{"id":"docs/LDF/101/cpp/04-your-first-query","body":""},{"id":"docs/LDF/101/cpp/05-whats-next","body":""},{"id":"docs/LDF/101/cpp/index","title":"Elements of Syntactical Program Analysis I for C/C++","body":"\n## Introduction\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat blandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque viverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus dictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis lectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus feugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra vitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et sollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum at varius vel.\n","topics":"dataflow, taint"},{"id":"docs/LDF/101/index","title":"LDF-101 - Elements of Syntactical Program Analysis I","body":"\n## Workshop Description\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\nincididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat\nblandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque\nviverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus\ndictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis\nlectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus\nfeugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra\nvitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et\nsollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum\nat varius vel.\n","topics":"LDF-101 - Elements of Syntactical Program Analysis I"},{"id":"docs/LDF/101/python/index","title":"Elements of Syntactical Program Analysis I for Python","body":"\n## Introduction\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat blandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque viverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus dictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis lectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus feugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra vitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et sollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum at varius vel.\n\nWrite a thing that can work through the list of things and do a thing.\n","topics":"Elements of Syntactical Program Analysis I for Python"},{"id":"docs/LDF/index","title":"Language Dependent Features","body":"\n## Overview\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ornare suspendisse sed nisi lacus sed viverra tellus. Orci dapibus ultrices in iaculis nunc. Aliquet porttitor lacus luctus accumsan. Sit amet dictum sit amet justo donec. Hac habitasse platea dictumst vestibulum rhoncus est. At lectus urna duis convallis convallis tellus. Sapien pellentesque habitant morbi tristique senectus et. Convallis convallis tellus id interdum velit laoreet id donec ultrices. Sit amet consectetur adipiscing elit ut aliquam. Accumsan tortor posuere ac ut consequat semper viverra nam. Consectetur adipiscing elit ut aliquam purus sit. Gravida arcu ac tortor dignissim convallis aenean et. Dui sapien eget mi proin sed libero enim. In hac habitasse platea dictumst vestibulum rhoncus est.\n\nElit scelerisque mauris pellentesque pulvinar pellentesque. Congue quisque egestas diam in arcu cursus euismod quis. Accumsan tortor posuere ac ut consequat semper viverra nam. Sit amet consectetur adipiscing elit ut aliquam purus sit. Quam id leo in vitae. Id volutpat lacus laoreet non curabitur gravida arcu ac tortor. Vitae et leo duis ut diam quam nulla porttitor. Turpis massa tincidunt dui ut. Proin nibh nisl condimentum id venenatis a condimentum. Arcu non sodales neque sodales ut etiam sit amet. Quis viverra nibh cras pulvinar mattis. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam. Consectetur purus ut faucibus pulvinar. Aliquam nulla facilisi cras fermentum odio eu feugiat pretium. Ultrices sagittis orci a scelerisque. Dolor sit amet consectetur adipiscing elit pellentesque. Amet mauris commodo quis imperdiet massa tincidunt nunc pulvinar sapien.\n\nAt elementum eu facilisis sed odio morbi. Sed adipiscing diam donec adipiscing tristique risus nec feugiat in. Vitae tempus quam pellentesque nec nam aliquam sem et tortor. Vivamus at augue eget arcu dictum varius duis at. Vivamus at augue eget arcu dictum. Lorem mollis aliquam ut porttitor. Lacus luctus accumsan tortor posuere ac. Eget est lorem ipsum dolor sit amet consectetur adipiscing. Consectetur a erat nam at lectus urna duis. Adipiscing at in tellus integer feugiat scelerisque varius morbi. Et malesuada fames ac turpis egestas sed. Enim praesent elementum facilisis leo vel fringilla. Non sodales neque sodales ut etiam sit amet nisl purus. Neque convallis a cras semper auctor neque vitae tempus. Erat velit scelerisque in dictum non consectetur a.\n","topics":"Language Dependent Features"},{"id":"docs/QLC/100/01-introduction","title":"Introduction","body":"\nThis workshop provides a tour of CodeQL, discussing the tooling and\nthe QL language.\n","topics":"Introduction"},{"id":"docs/QLC/100/02-setting-up-your-development-environment","title":"Setting up your development environment","body":"\nBefore we start we are going to spend some time to setup the development environment because that is essential for you to participate in the workshop.\n\nThe development environment will consist of:\n\n- [Visual Studio Code](https://code.visualstudio.com/)\n- The [CodeQL](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql) extension\n- The [CodeQL CLI](https://github.com/github/codeql-cli-binaries/releases/latest)\n\nFollow the next steps to set up your environment. Feel free to reach out for support if things aren't going as planned.\n\n1. Ensure you have the latest Visual Studio Code installed by downloading it from the [download page](https://code.visualstudio.com/Download) for your operating system and install it by following the [setup](https://code.visualstudio.com/docs/setup/setup-overview) instructions.\n2. Install the CodeQL extension from the [Extension Marketplace](https://code.visualstudio.com/docs/editor/extension-marketplace).\n\nThe CodeQL extension automatically installs and updates the CodeQL CLI. However, the extension managed CLI is inconvienient to use directly in a Visual Studio Code terminal or other terminal available on your system due to the isolation mechanisms applied to Visual Studio Code extensions. We want to directly use the CodeQL CLI for the tasks that haven't been made available through the CodeQL extension, such as create QL packs and building databases. No worries if that doesn't ring a bell yet. These topics will be discussed in this workshop.\n\nTo install the CodeQL CLI and configure the Visual Studio Code extension use the following steps. We have split up the instructions for those that have the [GitHub CLI](https://cli.github.com/) installed and [authenticated](https://cli.github.com/manual/gh_auth_login) and for those who don't.\n\n1. Install the CodeQL CLI with the GitHub CLI (GH)\n\n    For those that have GH you can install the CodeQL extension to manage CodeQL CLI installations:\n\n    ```bash\n    # Install the CodeQL extension\n    gh install codeql\n\n    # Install a CodeQL stub for use with the Visual Studio Code extension. Default directory is /usr/local/bin.\n    # For convenience, make sure the chosen path is added to your path environment variable.\n    # For Linux and MacOS, add it to the $PATH environment variable.\n    # For Windows, add it to the %PATH% environment variable.\n    gh codeql install-stub\n\n    # Install the latest version\n    gh codeql set-version latest\n    ```\n\n2. Install the CodeQL CLI manually\n\n    To manually install the latest CodeQL CLI download the archive corresponding to your operating system from the [release](https://github.com/github/codeql-cli-binaries/releases/latest) page. Unzip the archive to a location of choice, then make sure that location is added to your path environment variable. For Linux and MacOS, add it to the `$PATH` environment variable. For Windows, add it to the `%PATH%` environment variable.\n\n3. Verifying your CodeQL CLI setup\n\n    The CodeQL CLI has subcommands that can help with verify that the CLI is correctly set up.\n\n    Run the following command to show which languages are available for database creation.\n\n    ```bash\n    codeql resolve languages\n    ```\n\n    For the purpose of this workshop make sure that the `cpp` language is available.\n\n4. Configuring the CodeQL extension\n\n    With the CodeQL CLI installed we are going to configure the CodeQL extension to use the installed extension.\n\n    Locate the setting `codeQL.cli.executablePath` in the [user and workspace settings](https://code.visualstudio.com/docs/getstarted/settings) and update it to the absolute path of the CodeQL CLI executable if is not part of your system's path environment or just `codeql` (`codeql.exe` for Windows). The extension will notify you of any problems in case of a misconfiguration.\n","topics":"Setting up your development environment"},{"id":"docs/QLC/100/03-preparing-your-first-ql-query","title":"Preparing your first QL query","body":"\nWith the development environment set up we can start with writing your first\nquery. For this workshop, you will need to clone the repository `https://github.com/codeql-workshops/codeql-learning-catalog` and save your work in the\n`docs/QLC/100/src/problems` directory.\n\n```bash\ngit clone https://github.com/codeql-workshops/codeql-learning-catalog\n```\n\nAfter cloning the repository open the folder in Visual Studio Code.\n\nBefore we can write our actual query we need to create a [CodeQL pack](https://codeql.github.com/docs/codeql-cli/creating-and-working-with-codeql-packs/). A CodeQL pack is a unit of queries or libraries that can be shared. CodeQL pack also provides the necessary information to CodeQL to run a query part of that pack.\n\nLet's start with switching to the workshop directory to store our the workshop assets.\n\nIn Visual Studio Code, open the [integrated terminal](https://code.visualstudio.com/docs/terminal/basics) and run the following commands to create a CodeQL pack.\n\n```bash\ncd docs/QLC/100/\ncodeql pack init qlc-100/problems -d src\n```\n\nThis will create a subdirectory of `src` named `qlc-100/problems` which will contain the file `qlpack.yml` with the following contents:\n\n```yaml\n---\nlibrary: false\nname: qlc-100/problems\nversion: 0.0.1\n```\n\nThe `qlpack.yml` describes the metadata of a CodeQL pack through properties. A description of the properties can be found [here](https://codeql.github.com/docs/codeql-cli/about-codeql-packs/#qlpack-yml-properties). For now we start with this minimal CodeQL pack specification that states it is a query pack, as opposed to a library pack, via the key `library: false`. The difference will be become apparent when you publish a package. A query pack, when published, will include all its dependencies and a precompiled version of the queries to ensure a fast deployment and evaluation.\n\nWith the query pack set up we are going to create another query pack to hold our tests. CodeQL provides testing infrastructure to create system agnostic unit tests for your queries. System agnostic means that it will not depend on external dependencies and that the tests will provide the same results on different operating systems with different compilers/interpreters and libraries installed.\n\n```bash\ncodeql pack init --extractor cpp qlc-100-tests/problems -d tests\n```\n\nThis will generate a file (`qlpack.yml`), similar what we have seen before, with an additional property `extractor` set to the value `cpp`. Normally the target language is specified by the database, because a database can only target a single language. With the `extractor` property we inform the testing infrastructure to use the C/C++ extractor to create test databases to validate our queries.\n\nTo test a query in the `qlc-100/problems` CodeQL pack we need to inform the `qlc-100-tests/problems` CodeQL pack how to resolve that query. This can be achieved through the `dependencies` property.\n\nChange the `qlpack.yml` to match the following contents.\n\n```yaml\n---\nlibrary: false\nname: qlc-100-tests/problems\nversion: 0.0.1\nextractor: cpp\ndependencies:\n  \"qlc-100/problems\": \"*\"\n```\n\nA dependency is resolved by the CodeQL pack name and a version. While our query CodeQL pack has version `0.0.1` we specify the `*` value to direct the CodeQL package manager to consider a local version of the query pack before reaching out to the package registry to download the latest version.\n\nWith our query and test CodeQL pack up and running we can run the command `codeql pack ls` to list the CodeQL packs that the CodeQL CLI can resolve.\n\n```bash\n▶ codeql pack ls\nRunning on packs: qlc-100-tests/solutions, qlc-100/solutions.\nFound qlc-100/solutions@0.0.1\nFound qlc-100-tests/solutions@0.0.1\n```\n\nThe command doesn't list our just created problem packs. The\n`codeql-workspace.yml` files helps the CodeQL CLI resolve CodeQL packs when\nmultiple are defined in a project.\n\nOpen the file `codeql-workspace.yml` in `docs/QLC/100` and ensure it has the\nfollowing content by adding the item `\"*/problems/qlpack.yml\"`:\n\n```yaml\nprovide:\n  - \"*/solutions/qlpack.yml\"\n  - \"*/problems/qlpack.yml\"\n```\n\nWith the CodeQL workspace re-running the `codeql pack ls` command succeeds.\n\n```bash\n▶ codeql pack ls\nRunning on packs: qlc-100-tests/problems, qlc-100/problems, qlc-100-tests/solutions, qlc-100/solutions.\nFound qlc-100/problems@0.0.1\nFound qlc-100-tests/problems@0.0.1\nFound qlc-100/solutions@0.0.1\nFound qlc-100-tests/solutions@0.0.1\n```\n\nThe `provide` key holds an array of path patterns for CodeQL pack files (i.e., `qlpack.yml` files) that this directory provides. A CodeQL workspace can be considered a container for multiple CodeQL packs. Path patterns allow lightweight globbing where each path component can be a `*`: matching any path component, or `**`: matching multiple arbitrary path components. The latter is useful if your projects contains multiple CodeQL packs organized per category, for example per language. Then the CodeQL workspace file can contain a path pattern per category. For example:\n\n```yaml\nprovide:\n  - \"cpp/**/qlpack.yml\"\n  - \"java/**/qlpack.yml\"\n```\n\ncan be used for the directory tree:\n\n```yaml\n- cpp /\n  - github\n    - security-queries\n  qlpack.yml\n    - security-tests\n  qlpack.yml\n    - security-libs\n  qlpack.yml\n- java /\n  - github\n    - security-queries\n  qlpack.yml\n    - security-tests\n  qlpack.yml\n    - security-libs\n  qlpack.yml\n```\n","topics":"Preparing your first QL query"},{"id":"docs/QLC/100/04-writing-your-first-query","title":"Writing your first QL query","body":"\nNow that we have created our query and test CodeQL packs we can finally start with our first query!\n\nCreate the file `HelloWorld.ql` in the `qlc-100/problems` CodeQL pack with the following content:\n\n```c file=./src/solutions/HelloWorld.ql\n```\n\nThat is it for our first query. To determine if it works as intended we want to test it so we should add a unit test to our `qlc-100-tests/problems` CodeQL pack.\n\n1. Create a folder `HelloWorld` in the `qlc-100-tests/problems` directory.\n2. Add the file `HelloWorld.qlref` in the just created directory `HelloWorld` with the contents:\n\n    ```c file=./tests/solutions/HelloWorld.qlref\n    ```\n\n3. Add the file `HelloWorld.expected` in the just created directory `HelloWorld` with the contents:\n\n    ```c file=./tests/solutions/HelloWorld.expected\n    ```\n\nThe `HelloWorld.qlref` is a query reference file that references to a query to be tested. It is a path relative to a CodeQL pack.\n\n<details><summary>How does CodeQL know which CodeQL pack?</summary>\n\nCodeQL will go through the dependencies to determine which CodeQL pack contains the query.\n\n</details>\n\nInstead of a query reference file you can also specify a query file directly. However, it is common to separate them into their own CodeQL packs so they can be independently be published and deployed.\n\nThe `HelloWorld.expected` file contains the expected output when running the query on a database built from files residing in the `HelloWorld` directory. In our case we have none, so the database will be empty.\n\nWith the qlpack specification for the test we can run the test using the [Test Explorer UI](https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-test-explorer) extension that is installed as a dependency of the CodeQL extension.\n\n![img](/assets/images/QLC/100/test-explorer-ui-extension.png \"The HelloWorld test listed in the Test Explorer UI\")\n\nWe can run the test from the Test Explorer UI or run the test from the terminal with the command:\n\n```bash\ncodeql test run tests/problems/HelloWorld\n```\n\nEither way, running the test will result in the error:\n\n```bash\nError: Could not locate a dbscheme to compile against.\nYou probably need to specify a libraryPathDependencies list in\n/.../src/qlpack.yml\n```\n\nThe test is unable to determine the database schema to our query in the `qlc-100/problems` CodeQL pack. Every CodeQL database adheres to a language specific database schema and every query should adhere to the same schema so it can correctly query the database. The database schema for queries (as supposed to the extractor creating the database) is located in the standard library `all` pack of the language we want to query.\n\nWhile we remain language agnostic with the queries discussed in this workshop, we still need to pick a language for the database schema. Adjust the `qlpack.yml` of the `qlc-100/problems` CodeQL pack to match the following content:\n\n```yaml\n---\nlibrary: false\nname: qlc-100/problems\nversion: 0.0.1\ndependencies:\n  \"codeql/cpp-all\": \"*\"\n```\n\nTo ensure the dependency is available we need to run the command:\n\n```bash\n▶ codeql pack install qlc-100/problems\nDependencies resolved. Installing packages...\nInstall location: /.../.codeql/packages\nPackage install location: /.../.codeql/packages\nAlready installed codeql/cpp-all@0.4.3 (library)\n```\n\nThrough the `qlc-100/problems` CodeQL pack the `qlc-100-tests/problems` CodeQL pack has a dependency on `codeql/cpp-all` as well. So we need to resolve those dependencies by running the command:\n\n```bash\n▶ codeql pack install qlc-100-tests/problems\nDependencies resolved. Installing packages...\nInstall location: /.../.codeql/packages\nPackage install location: /.../.codeql/packages\nAlready installed codeql/cpp-all@0.4.3 (library)\n```\n\nWith all the dependencies resolved we can re-run the test. Try running both from Testing Explorer UI and using the CodeQL CLI.\n\nCongrats, you have written your first query!\n","topics":"Writing your first QL query"},{"id":"docs/QLC/100/05-the-structure-of-ql-query","title":"The structure of a QL query","body":"\nOur first query didn't provide a lot of information around the structure of a QL query besides the use of the `select` keyword.\n\nA typical query contains the following elements:\n\n- Query metadata.\n- Import statements\n- Definitions of classes and predicates\n- The `from`, `where`, and `select` clause.\n\nLet start exploring these components from the bottom up.\n\n1. The `select` clause\n\n    For those familiar with query languages such as SQL the syntax of the `select` clause, consisting of the two optional `from` and `where` parts and the mandatory `select` part, should look familiar.\n\n    ```ql\n    from ...\n    where ...\n    select ...\n    ```\n\n    The `from` part can be used to declare variables. Each variable represents a set of values of the same sort described by the variable's type. Because sets of values can overlap (that is, their intersection is not empty) it can be the case that values have multiple types.\n\n    <details><summary>Can you think of an example of a value in a program that would be described by multiple types?</summary>\n\n    For example, a type representing all the expressions in a program and a type representing all the arithmetic expressions in a program.\n\n    </details>\n\n    The following examples describe types and the values they represent.\n\n    - The primitive type `int` with each value being a 32-bit two's complement integer.\n    - The primitive type `string` with each value being a finite sequence of 16-bit characters, each interpreted as a Unicode code point.\n    - The class `Expr` with each value being an expression in a program (part of the database being queried).\n\n    Note that in the last example we used the term *class* instead of *type*. In QL you can define your own *type* by defining a *class*.\n\n    To reason about the variables and their values we can further restrict the values of the variables in the `where` part.\n\n    QL is a *logic programming language* and is built up of logical formulas. In the `where` part we can use formulas to define logical relations between expressions and are of the form `<expr> <op> <expr>`. Wait, didn't we discussed variables instead of expressions?\n\n    [Expressions](https://codeql.github.com/docs/ql-language-reference/expressions/) evaluate to a set of values.\n\n    <details><summary>What determines the set of values?</summary>\n\n    The set of values an expression evaluates to is determined by a type.\n\n    </details>\n\n    During query writing we will get introduced to the many kinds of expressions. For now we will continue with variables. In a formula a variable can be referenced using a *[variable reference](https://codeql.github.com/docs/ql-language-reference/expressions/#variable-references)*.\n\n    Finally, we have the [select clause](https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses) that determines what we want to *select* as a result for the query. The result of a query will be a set of ordered tuples commonly represented as a table with columns and rows. The columns are determined by the expression provided to the `select` clause. The provided *expressions* **must** evaluate to a value part of a *primitive type*. We will discuss what *primitive types* later on in this workshop. Classes have a *member predicate* `toString` that is used to convert them to a `string`.\n\n    The `as` keyword can be used to label to a column of results and allows the result to be referenced in other expressions part of the select clause. The `order by` keyword allows you to sort the result set. To control the ordering you can use the keywords `asc`, for ascending, and `desc` for descending.\n\n    Let's have a look at some concrete examples!\n\n    1. Add the query `FromWhereSelect.ql` to the CodeQL pack `qlc-100/problems` with the following contents\n\n        ```ql file=./src/solutions/FromWhereSelect.ql\n        ```\n\n    2. Add a directory `FromWhereSelect` with the files `FromWhereSelect.qlref` and `FromWhereSelect.expected` to the CodeQL pack `qlc-100-tests/problems`. Make sure to add the path `FromWhereSelect.ql`, the path to the query relative to the CodeQL pack it belongs to, in the `FromWhereSelect.qlref` file.\n\n    3. Run the newly created QL test.\n\n    The test will fail and output the following result.\n\n    ```diff file=./tests/solutions/FromWhereSelect.expected\n    ```\n\n    <details><summary>Why did the test fail?</summary>\n\n    The output of the query didn't match our test's expected file.\n\n    </details>\n\n    For each test that fails, the CodeQL extension keeps the database so we can investigate why the test failed. In the directory `FromWhereSelect` there should be an additional directory named `FromWhereSelect.testproj`. You can mount the test database with the command `CodeQL: Set Current Database` that is available in the context menu when you right click on the directory `FromWhereSelect.testproj` in the Visual Studio Code file explorer.\n\n    ![img](/assets/images/QLC/100/mount-testproj.png \"Select the failed test database as the current database.\")\n\n    To investigate a failed test you can make use of the `CodeQL: Quick query` functionality. This allows you to quickly create a one-off query for a mounted database.\n\n    To test this, perform the following steps:\n\n    1. Mount the `FromWhereSelect.testproj` database.\n    2. Execute the command `CodeQL: Quick Query` using the Visual Studio Code [Command Palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette). Answer with Yes when prompted to reload the workspace as a multi-folder workspace, and yes when prompted to trust the workspace.\n\n    In the Visual Studio Code Explorer you can now find a new folder named `Quick Queries` with, among others, a file `quick-query.ql` with the contents\n\n    ```ql\n    import cpp\n\n    select \"\"\n    ```\n\n    ![img](/assets/images/QLC/100/quick-query-folder.png \"Quick query folder added to the workspace\")\n\n    The contents of the `quick-query.ql` file has been setup to match the language of your selected database. The language can also be seen in the database section of the CodeQL extension.\n\n    ![img](/assets/images/QLC/100/codeql-databases-section.png \"CodeQL extension databases section\")\n\n    The query can be executed using the command `CodeQL: Run Query` via the Command Palette or the right-click menu.\n\n    Once you have established why the test cased failed, and corrected your query you can re-run the test. If you start with an empty `FromWhereSelect.expected` file you can accept the test output via the right-click menu that is available on the test or run the CodeQL CLI command `codeql test accept tests/problems/FromWhereSelect/FromWhereSelect.qlref`.\n\n    ![img](/assets/images/QLC/100/accept-test-output.png \"Accept test output\")\n\n2. Imports\n\n    QL supports [modules](https://codeql.github.com/docs/ql-language-reference/modules/#modules) to organize and reuse QL code. Each query file, with the extension `.ql`, and library file, with the extension `.qll`, *implicitly* defines a module. The `import` statement can be used to import public names (i..e, not annotated [private](https://codeql.github.com/docs/ql-language-reference/annotations/#private)), of a library module, into the namespace of the current module containing the `import` statement.\n\n    By convention the first statement in a query module is the import of the language library you are targeting. For example, `import cpp`.\n\n    Modules will not be further discussed in this quick-start.\n\n3. Query metadata\n\n    A query has properties that provide information to users of a query and provides information to consumer of the query result on how to display its results. These properties are known as query metadata.\n\n    The query metadata resides at the top in a query file as a [QLDoc comment](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#qldoc-qldoc). A QLDoc comment starts with a `/**`, ends with a `*/`, and can span multiple lines. The body of QLDoc, the *contents*, is compromised of all the text surrounded by~/\\*\\*~ and `*/`. For each line the leading whitespace followed by a `*` is ignored and excluded from the content. The [contents](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#content) is interpreted as [CommonMark](https://commonmark.org/). The properties of a query are specified as tags. A tag is started with a `@` sign followed by any number of non-whitespace characters to form the *key* of the tag. A single whitespace character separates the key from the value, with the value being the remainder of the line.\n\n    The supported properties of a query can be found [here.](https://codeql.github.com/docs/writing-codeql-queries/metadata-for-codeql-queries/#metadata-properties) The next snippet shows the metadata for a standard library query.\n\n    ```ql\n    /**\n    * @name Uncontrolled data used in OS command\n    * @description Using user-supplied data in an OS command, without\n    *              neutralizing special elements, can make code vulnerable\n    *              to command injection.\n    * @kind path-problem\n    * @problem.severity error\n    * @security-severity 9.8\n    * @precision high\n    * @id cpp/command-line-injection\n    * @tags security\n    *       external/cwe/cwe-078\n    *       external/cwe/cwe-088\n    */\n    ```\n\n    Here are a few takeaways for query metadata when consuming the results in GitHub Code Scanning:\n\n    - A `@name` property is **required** and defines a display name for the query. The [metadata style guide](https://github.com/github/codeql/blob/master/docs/query-metadata-style-guide.md#query-name-name) prescribes you should use sentence capitalization without a full stop.\n    - A `@description` property is **required** and defines a short help message. The [meta data style guide](https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md#query-descriptions-description) prescribes you should be written as a sentence or a short paragraph with sentence capitalization and a full stop.\n    - A `@id` property is **required**. The id must uniquely identify a query and *should* follow the CodeQL convention by starting the id with a *language code* followed by a `/`. The remainder of the id should consists of a short noun phrase. For example, `cpp/command-line-injection`. Additional terms can be added to group queries. For example, `js/angular-js/missing-explicit-injection` and `js/angular-js/dpulicate-dependency`. **Note: Code Scanning uses the id to track alerts, changing the id will result in alerts tracked with the old id being closed and new alerts with the new id being introduced.**\n    - A `@kind` property is **required**. There are multiple query types, but the most common alert kinds are: `problem` and `path-problem`. The kind property determines how to display the result of a query and expects a specific `select` form described in [Defining the results of a query](https://codeql.github.com/docs/writing-codeql-queries/defining-the-results-of-a-query/) and [Creating path queries](https://codeql.github.com/docs/writing-codeql-queries/creating-path-queries/#creating-path-queries).\n    - A `@precision` property is *optional* for alert queries and indicates the proportion of true positives expected for the query. Possible values are:\n        - `low`, expect a lot of false positives\n        - `medium`, expect a moderate number of false positives\n        - `high`, expect a low number of false positives\n        - `very-high`, expect false positives in exceptional cases\n    - A `@problem.severity` property is *optional* for alert queries and indicates the severity for alerts. Possible values are:\n        - `error`, an issue that likely results in incorrect program behavior such as a crash or vulnerability\n        - `warning`, an issue indicating a potential problem and could become a problem due to changes in the code.\n        - `recommendation`, an issue that indicates code behaves correctly, but could be improved.\n    - A `@tags` property is *optional*. Tags can be used to group queries into categories for identification purposes. The common tags are: `correctness`, `maintainabilility`, `readability`, `security`. Other known uses cases are to tag a query with a known weakness classification such as a [CWE](https://cwe.mitre.org/) or [OWASP Top 10](https://owasp.org/Top10/). Our standard queries, for example, use a CWE tag like `external/cwe/cwe-119`.\n        - An additional `@security-severity` property is available for queries with `security` tag. This defines a severity with the range `0.0` - `10.0`. The blog [CodeQL code scanning: new severity levels for security alerts](https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/) describes how to compute a severity.\n\n    The query properties can be used to filter which queries are part of a [CodeQL query suite](https://codeql.github.com/docs/codeql-cli/creating-codeql-query-suites/#filtering-the-queries-in-a-query-suite). This won't be discussed in this quick-start.\n","topics":"The structure of a QL query"},{"id":"docs/QLC/100/06-the-essence-of-a-ql-query","title":"The essence of a QL query","body":"\nWith a basic understanding of the structure of a query we can continue looking at the building blocks of queries, namely *types*, *expressions*, *formulas*, and *predicates*.\n\nIn essence, a query is about relating types and their values. By solving a logic puzzle we are going to learn more about the building blocks and how they can be used.\n\n### Predicates\n\nLet's start with a simple logic puzzle. There are five racers named `A`, `B`, `C`, `D`, and `E`. Each finish the race as follows:\n\n- `C` finishes before `B`, but not before `D`\n- `E` finishes before `A`, but not before `B`\n\nWhat is the finish order?\n\nWe have a relation between racers that determines who finishes before another racer. How can we capture such a relation?\n\nLet's start with a first attempt where we use integers combined with comparison expressions. Create the query file `PuzzleOneAttemptOne.ql` and the corresponding QL test files in the directory `PuzzleOne`.\n\n```ql file=./src/solutions/PuzzleOneAttemptOne.ql\n```\n\nWhen we run this query we get the following results.\n\n```diff file=./tests/solutions/PuzzleOneAttemptOne.expected\n```\n\nRepresenting the correct result `D` `C` `B` `E` `A`.\n\nHowever, the query doesn't seem very *elegant*. We have to manually construct the final result. What if we add more racers, lets say up to a total of 1024? That would become very unwieldy. We need a better way to capture the relation between two racers.\n\nIn logic, a *predicate* represents a property or relation. QL, being a logical language, supports predicates. Create the query file `PuzzleOneAttemptTwo.ql` and the corresponding QL test files. In the query file define the predicate `finishesBefore` that captures the relation between the racers.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoA.ql\n```\n\nRun the `PuzzleOneAttemptTwo.qlref` test and mount the test database `PuzzleOne.testproj` of the failed test. Note that the test database has the name of the test directory, because the parent directory of each `.qlref` file is used to construct a test database.\n\nWith the test database mounted we can now test our predicate `finishesBefore` with quick evaluation. The Visual Studio Code editor will provide hints as to what can be quick evaluated.\n\n![img](/assets/images/QLC/100/quick-evaluation.png \"Quick evaluating hint on `finishesBefore` predicate.\")\n\nThe result of quick evaluating the `finishesBefore` predicate should match:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwoA.expected\n```\n\nThe quick evaluation functionality is super useful when debugging your logic. Besides the hints provided by Visual Studio Code you can also select *formulas*, *expressions*, and *types* and quick evaluate them with a right-click to access the `CodeQL: Quick Evaluation` command.\n\n![img](/assets/images/QLC/100/partial-quick-evaluation.png \"Quick evaluating the first two disjunctions.\")\n\nTo find the finish order we want to *connect* the tuples created by the predicate `finishesBefore`. For example, `(D, C)` and `(C, B)` to get a partial finish order `(D,C,B)`. That is, the second argument in one predicate call becomes the first argument in another call.\n\n<details><summary>Implement a query to find the partial finish order `D C B` using the `finishesBefore` predicate.</summary>\n\n```ql\nfrom string one, string two, string three\nwhere one = \"D\" and finishesBefore(one, two) and finishesBefore(two, three)\nselect one, two, three\n```\n\n</details>\n\nThe solution works well for this partial finish order, but we are back to representing each of the racers as a variable and having to make multiple predicate calls to get the complete finish order.\n\nThis repeated connecting of predicate calls is a common pattern in reachability problems and are typically concerned with whether one location can reach another location given a step function. More concrete examples are:\n\n- Can function `foo` reach function `bar` through function calls?\n- Can the value of variable `foo` reach argument `bar` of function `baz`?\n\nWe can treat the finish order problem as a reachability problem by finding the path from the first finisher to the last.\n\nQL supports the repeated application of a predicate through recursion. In a recursive predicate we have to consider two cases:\n\n1. The base case, which determines when we are done.\n2. The recursive case\n\nThe following example demonstrates how recursion can be used to find all the finishers after a certain finisher. Note that we renamed the predicate `finishesBefore` to `finishesBeforeStep` to highlight it is a step function.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoB.ql#L1-L17\n\n```\n\nThe base case is our step predicate `finishesBeforeStep`, finding all the finishers reachable with a single step. The recursive case uses the [quantified formula](https://codeql.github.com/docs/ql-language-reference/formulas/#quantified-formulas) [exists](https://codeql.github.com/docs/ql-language-reference/formulas/#exists). Quantified formulas allow us to introduce temporary variables that we can use in the formula's body to create new formulas from existing ones. The `exists` formula has the syntax `exists(<variable declarations> | <formula>)`. The syntax used in our example, `exists(<variable declarations> | <formula1> | <formula2>)`, is equivalent to `exists(<variable declarations> | <formula1> and <formula2>)`.\n\nWe use the `exists` to create a new formula from the predicate `finishesBeforeStep` and the predicate `finishesBefore` to find another racer that we can reach with a single step and all the racers that reachable from that other racer.\n\nQuick evaluating the new `finishesBefore` predicate provides us with the result:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwoB.expected\n```\n\nBecause this type of recursion is very common QL has implemented a shortcut that computes a [transitive closure](https://codeql.github.com/docs/ql-language-reference/recursion/#transitive-closures) of a predicate. The transitive closure is obtained by repeatedly calling a predicate.\n\nQL has two types of transitive closures. The transitive closure `+` that calls a predicate one ore more times. The reflexive transitive closure `*` calls a predicate zero or more times. The transitive closure of a predicate call can be used by appending a `+` or a `*` to the predicate name in a predicate call.\n\nUsing our step function we can compute the transitive closure by calling it as `finishesBeforeStep+(racerOne, racerTwo)`.\n\nThe transitive closure cannot be used on all predicate calls. The predicate must have two arguments with types that are [compatible](https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility).\n\n<details><summary>Write a query that uses the transitive closure of the predicate `finishesBeforeStep` to compute the same results as the recursive predicate `finishesBefore`.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoC.ql#L11-L14\n\n```\n\n</details>\n\nTo determine if the results are the same you can use the `Compare Results` option in the `Query History` pane of the CodeQL extension.\n\nSelect to last two items in the history, right-click, and select `Compare Results`. This should result in an empty comparison.\n\n![img](/assets/images/QLC/100/compare-results.png \"Compare query results\")\n\nWith our transitive closure we are almost done with finding the finish order. First we want to limit the reachable racers from the first finisher. Secondly we want a single answer.\n\nLet's continue with determining which racer is the first to finish.\n\n<details><summary>How can you determine who is the first finisher?</summary>\n\nThe first finisher is a finisher with no finisher before them. That is, it is not the case there exists another finisher that finishes before the first one.\n\n</details>\n\nIn QL you can negate a formula by prepending a `not` to that formula. For example, the following query returns all pairs where `racerOne` does not finish before `racerTwo`.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoD.ql#L11-L16\n```\n\nThe extra equality expressions for `racerOne` and `racerTwo` are required because we can't determine the range of values for `racerOne` and `racerTwo` from a negation. That is, `not` is not [binding](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding). Without those the CodeQL will give an error that `racerOne` and `racerTwo` are not bounded to a value. This is caused by the fact that many of the primitive types including `string` are infinite. They have an infinite number of values. Since QL can only work with finite results we need to restrict the set of values for the result. Before, that was done by the `finishesBeforeStep` predicate.\n\nTo restrict the set of values we use the member predicate `charAt` that expects an index. We, however, are not interested in a particular index so we pass the [dont'-care expression](https://codeql.github.com/docs/ql-language-reference/expressions/#don-t-care-expressions). That is any value which will result in calling the predicate with all the indices binding the racers to the characters `[\"A\", \"B\", \"C\", \"D\", \"E\"]`. `racerOne = \"ABCDE\".charAt(_)` is equivalent to `racerOne = [\"A\", \"B\", \"C\", \"D\", \"E\"]` where the latter is the [set literal expression](https://codeql.github.com/docs/ql-language-reference/expressions/#set-literal-expressions) we used in the very beginning.\n\n<details><summary>Using the `not` formula, write a predicate `firstFinisher` that holds if a finisher is the first finisher. Remember, `not` is not [binding](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding).</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoE.ql#L11-L14\n```\n\n</details>\n\nWith the `firstFinisher` predicate we can now limit the results to the first finisher and all those that are reachable from the first finisher.\n\n<details><summary>Write a query that returns the first finisher and all the finisher reachable from that first finisher.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoF.ql#L16-L18\n```\n\n</details>\n\nSo now we have the first finisher and all those that finish after. However, there are still multiple results. The last task is to [aggregate](https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations) the finishers to get the final finish order.\n\nIn our case the aggregate `[[https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations][concat]]` looks interesting, however, we can't properly control the order of the results which in this case is important.\n\nThat is, the following does not give the correct order because strings are sorted lexicographically.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoG.ql#L16-L20\n```\n\n<details><summary>Why does the query use the reflexive transitive closure operator `*`?</summary>\n\nTo include the `firstFinisher` that does not have a finisher before them.\n\n</details>\n\nThat means we need to build the final finish order ourselves, recursively. We have seen recursion and the closely related transitive closure before. In most cases the transitive closure is sufficient, but sometimes you want more control. For example when the goal is to find all the functions reachable from a function `entrypoint` that are not reachable by an authorization function to determine authentication bypasses.\n\nIn this case we want to build up the finish order from the first finisher. A recursive problem requires two cases, the base case, and the recursive case.\n\n<details><summary>The base case determines when we are done. What would that be in our problem?</summary>\n\nWhen we have reached the last finisher.\n\n</details>\n\n<details><summary>Implement the predicate `lastFinisher` using the already defined predicate `finishesBeforeStep`. You can take inspiration from the predicate `firstFinisher`. Remember that the `not` does not *bind*.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoH.ql#L16-L18\npredicate lastFinisher(string racer) {\n    not finishesBeforeStep(racer, _) and finishesBeforeStep(_, racer)\n}\n```\n\n</details>\n\n<details><summary>Write the predicate `finishOrderFor`. QL supports [predicates with results](https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-with-result). A predicate with a result is defined by replacing the keyword `predicate` with the type of the result. The result can be referenced through a special variable `result`. Semantically it is the same as predicates without a result, the result would just be a parameter, but it can result in a more readable query because you can omit a `exists`.\n\n```ql\nstring finishOrderFor(string racer) {\n    none() // replace with implementation\n}\n```\n\n</summary>\n\nWith the predicate `finishesBeforeStep` rewritten as a predicate with a value, and the predicate `finishOrderFor` written as a predicate with a value, the complete query becomes.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwo.ql\n```\n\nThe result of this query should be:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwo.expected\n```\n\n</details>\n","topics":"The essence of a QL query"},{"id":"docs/QLC/100/07-conclusion","title":"Conclusion","body":"\nIn this quickstart we have:\n\n- setup a development environment,\n- looked at CodeQL packs for queries and tests,\n- learned about the structure of a query, and\n- used predicates to solve a logic puzzle.\n","topics":"Conclusion"},{"id":"docs/QLC/100/index","title":"QLC 100 - QL Quickstart","body":"\n## Introduction\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat blandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque viverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus dictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis lectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus feugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra vitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et sollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum at varius vel.\n","topics":"QLC 100 - QL Quickstart"},{"id":"docs/QLC/index","title":"QL Core","body":"\n## Overview\n\nConsectetujr adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ornare suspendisse sed nisi lacus sed viverra tellus. Orci dapibus ultrices in iaculis nunc. Aliquet porttitor lacus luctus accumsan. Sit amet dictum sit amet justo donec. Hac habitasse platea dictumst vestibulum rhoncus est. At lectus urna duis convallis convallis tellus. Sapien pellentesque habitant morbi tristique senectus et. Convallis convallis tellus id interdum velit laoreet id donec ultrices. Sit amet consectetur adipiscing elit ut aliquam. Accumsan tortor posuere ac ut consequat semper viverra nam. Consectetur adipiscing elit ut aliquam purus sit. Gravida arcu ac tortor dignissim convallis aenean et. Dui sapien eget mi proin sed libero enim. In hac habitasse platea dictumst vestibulum rhoncus est.\n\nElit scelerisque mauris pellentesque pulvinar pellentesque. Congue quisque egestas diam in arcu cursus euismod quis. Accumsan tortor posuere ac ut consequat semper viverra nam. Sit amet consectetur adipiscing elit ut aliquam purus sit. Quam id leo in vitae. Id volutpat lacus laoreet non curabitur gravida arcu ac tortor. Vitae et leo duis ut diam quam nulla porttitor. Turpis massa tincidunt dui ut. Proin nibh nisl condimentum id venenatis a condimentum. Arcu non sodales neque sodales ut etiam sit amet. Quis viverra nibh cras pulvinar mattis. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam. Consectetur purus ut faucibus pulvinar. Aliquam nulla facilisi cras fermentum odio eu feugiat pretium. Ultrices sagittis orci a scelerisque. Dolor sit amet consectetur adipiscing elit pellentesque. Amet mauris commodo quis imperdiet massa tincidunt nunc pulvinar sapien.\n\nAt elementum eu facilisis sed odio morbi. Sed adipiscing diam donec adipiscing tristique risus nec feugiat in. Vitae tempus quam pellentesque nec nam aliquam sem et tortor. Vivamus at augue eget arcu dictum varius duis at. Vivamus at augue eget arcu dictum. Lorem mollis aliquam ut porttitor. Lacus luctus accumsan tortor posuere ac. Eget est lorem ipsum dolor sit amet consectetur adipiscing. Consectetur a erat nam at lectus urna duis. Adipiscing at in tellus integer feugiat scelerisque varius morbi. Et malesuada fames ac turpis egestas sed. Enim praesent elementum facilisis leo vel fringilla. Non sodales neque sodales ut etiam sit amet nisl purus. Neque convallis a cras semper auctor neque vitae tempus. Erat velit scelerisque in dictum non consectetur a.\n","topics":"QL Core"}]