export const posts = [{"id":"LDF/101/cpp/01-introduction","title":"Introduction","body":"\nIn this workshop, we use CodeQL to analyze the source code of a [vulnerable Linux driver](https://github.com/invictus-0x90/vulnerable_linux_driver) to pinpoint a portion of source code that causes a buffer overflow.\n\nThe Linux kernel allows users to register their simple drivers as a [miscellaneous character driver](https://www.linuxjournal.com/article/2920) (henceforth misc driver), and this project aims to provide a misc driver ready to be inserted into the kernel. Linux misc drivers need to be added and removed to the kernel via two API functions provided by the kernel, [`misc_register`](https://github.com/torvalds/linux/blob/8ca09d5fa3549d142c2080a72a4c70ce389163cd/include/linux/miscdevice.h#L91) and [`misc_unregister`](https://github.com/torvalds/linux/blob/8ca09d5fa3549d142c2080a72a4c70ce389163cd/include/linux/miscdevice.h#L92), respectively.\n\nLooking close to the source code of this project, we can see it [register a vulnerable device](https://github.com/invictus-0x90/vulnerable_linux_driver/blob/2bbfdadd403b6def98f98f6ee3f465286f35e0c9/src/vuln_driver.c#L156) represented as a `static struct` that contains another struct that implements `file_operations` which bridges between user-space application code (performing I/O with the device) and the kernel. The vulnerable point is the `do_ioctl` function being registered as that user-space code, hence the aim of our investigation.\n\nStarting from the `misc_register` function we will traverse function calls, expressions, structure definitions, and variable initializations to find this entrypoint `do_ioctl`. In the course of this investigation, you will learn how to express our interest in a query language CodeQL and learn that we are able to go quite far only by syntactic analysis that combines various constraints together using formulas, predicates, and classes.\n\nThe workshop is split into several steps. You can write one query per step, or work with a single query that you refine at each step. Each step has a **hint** that suggests useful classes and predicates in the CodeQL standard libraries for C/C++. You can explore these in VSCode using the autocomplete suggestions `Ctrl+Space` and the `Go to Definition` command bound to `F12`.\n","topics":"Introduction"},{"id":"LDF/101/cpp/02-setup-instructions","title":"Setup Instructions","body":"\nBefore we move on to write our queries, let us set up our development environment of choice: there are two such ones we recommend: GitHub Codespaces and making a local copy, though we strongly prefer the former.\n\n### GitHub Codespaces\n\nThis is the easiest and fastest way to get started!\n\n1. From the command palette (bound to `Ctrl+Shift+P` or `Cmd+Shift+P`), choose `CodeQL: Choose Database from Archive`.\n2. Choose `vld.zip` provided by Git LFS.\n\n### Working locally\n\n1. Install [Visual Studio Code](https://code.visualstudio.com/).\n2. Install the [CodeQL extension for Visual Studio Code](https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/).\n3. Clone this repository and additionally run `git lfs pull` to get the precompiled database to work on.\n4. Install the CodeQL pack dependencies using the command `CodeQL: Install Pack Dependencies` and select `ldf-101-cpp-src`.\n5. From the command palette (bound to `Ctrl+Shift+P` or `Cmd+Shift+P`), choose `CodeQL: Choose Database from Archive`.\n6. Choose `vld.zip` provided by Git LFS.\n\n## Documentation Links\n\nIf you get stuck, try searching our documentation and blog posts for help and ideas. Below are a few links to help you get started:\n\n- [Learning CodeQL](https://codeql.github.com/docs/writing-codeql-queries/)\n- [CodeQL Language Guides for C/C++](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n- [CodeQL Standard Library for C/C++](https://codeql.github.com/codeql-standard-libraries/cpp)\n- [CodeQL](https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/)\n- [Using the CodeQL extension for VSCode](https://codeql.github.com/docs/codeql-for-visual-studio-code/)\n","topics":"Setup Instructions"},{"id":"LDF/101/cpp/03-identifying-function-calls","title":"Identifying the Linux Driver API Call","body":"\nWe track the insecure function in question, the I/O function which overflows the buffer, backwards from the API call `misc_register` that registers a vulnerable driver. We take a number of steps to actually get there, so keep track of where we are at and where we are heading towards during the workshop!\n\n## Exercise 1\n\nSince we are first looking for calls to the function `misc_register`, we start off by listing all the function calls in the program. Find all the function calls in the program by implementing [Exercise1.ql](exercises/Exercise1.ql).\n\n<details>\n<summary>Hints</summary>\n\n- The class `FunctionCall` can be used to reason about function calls in the program.\n\n</details>\n\n## Exercise 2\n\nThat's a big list of function calls! So let's narrow it down to what we're actually looking for. Filter out rows from the previous table to only have the calls to function `misc_register` by implementing [Exercise2.ql](exercises/Exercise2.ql).\n\n<details>\n<summary>Hints</summary>\n\n- The class `FunctionCall` provides the member predicate `getTarget` to refer to the called function.\n- The class `Function` provides the member predicate `getName` to get the name of the function.\n\n</details>\n\nThere should be only one such call if the result is correct. Is that the one inside the definition of `vuln_module_init` as seen below?\n\n```c\n/**\n* Register the device.\n*/\nstatic int vuln_module_init(void)\n{\n    int ret;\n\n    ret = misc_register(&vuln_device);\n\n    ...\n}\n```\n\n## Exercise 3\n\nSo far, we have been adding our constraints to the `where` clause directly. That works, but it makes the `where` clause increasingly hard to read and makes it hard for us to introduce new concepts to be used in some of the constraints. [Predicates](https://codeql.github.com/docs/ql-language-reference/predicates/) and [classes](https://codeql.github.com/docs/ql-language-reference/types/#classes) allow you to do that by capturing logical conditions in a reusable format.\n\nConvert your solution to [Exercise2.ql](exercises/Exercise2.ql) into a CodeQL class in [Exercises3.ql](exercises/Exercise3.ql) by replacing the [none](https://codeql.github.com/docs/ql-language-reference/formulas/#none) formula in the [characteristic predicate](https://codeql.github.com/docs/ql-language-reference/types/#characteristic-predicates) of the `MiscRegisterFunction` class. Also, besides relying on the name, try to add another property to distinguish the function we're looking for. What about the path to the file a program element lives in?\n\n<details>\n<summary>Hints</summary>\n\n- Each program element represented by the class `Element` can be related to the primary file the element occurs in using the member predicate `getFile`.\n- Each program element has an absolute path that can be accessed using the member predicate `getAbsolutePath` on the class `File`.\n- The QL `string` type provides [built-in member predicates](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string) such as `matches` and `regexpMatch` to match patterns in strings. The `matches` predicate interprets `_` to match any single character and `%` to match any sequences of characters in the provided pattern.\n\n</details>\n","topics":"Identifying the Linux Driver API Call"},{"id":"LDF/101/cpp/04-reasoning-about-miscdevice","title":"Reasoning about the Driver Definition","body":"\nNow that we found the call to `misc_register` in question, we shift gears to its argument `&vuln_device`, a representation of the problematic driver. This seems interesting, so let us inspect this object in detail.\n\n## Exercise 4\n\nFirst, identifying the type of the object `vuln_device` might be a good start. Obtain the argument to the call to `misc_register`, the argument's type and the QL class that most precisely represents it by implementing [Exercise4.ql](exercises/Exercise4.ql).\n\n<details>\n<summary>Hints</summary>\n\n- The class `FunctionCall` provides the member predicate `getArgument` to get an argument by index.\n- Each expression represented by the class `Expr` has a type that can be retrieved with the member predicate `getType`.\n- Each program element represented by the class `Element` has a member predicate `getPrimaryQlClass` that returns the QL class that is the most precise syntactic category the element belongs to.\n- Relate QL expressions as much as you can. Relate the call to the misc_register call to the misc_register function, use it to retrieve its argument, and again associate to its type and the primary QL class. `Select` the latter three.\n\n</details>\n\nDoes the result indicate that the argument `&vuln_device` is some address of an expression?\n\n## Exercise 5\n\nThe `vuln_device` object is of type `struct miscdevice`, defined in one of the Linux headers. If we represent this `struct`, it may be useful later on. Why don't we model it as a class called `MiscDeviceStruct`? Complete the characteristic predicate of the class `MiscDeviceStruct` in [Exercise5.ql](exercises/Exercise5.ql) so we can reason about its use.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Struct` inherits the member predicate `getName` from the class `UserType` that returns the name of the struct.\n- Each program element represented by the class `Element` can be related to the primary file the element occurs in using the member predicate `getFile`.\n- Each program element has an absolute path that can be accessed using the member predicate `getAbsolutePath` on the class `File`.\n- The QL `string` type provides [built-in member predicates](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string) such as `matches` and `regexpMatch` to match patterns in strings. The `matches` predicate interprets `_` to match any single character and `%` to match any sequences of characters in the provided pattern.\n\n</details>\n\n## Exercise 6\n\nNow that we have the representation of `struct miscdevice`, we can look for all it instantiations. Implement the characteristic predicate of the class `MiscDeviceDefinition` in [Exercise6.ql](exercises/Exercise6.ql) so we can use it to find all its instances.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Variable` has a member predicate `getType` that gets the type of this variable.\n\n</details>\n\n### Exercise 7\n\nThe instantiation `vuln_device` initializes 3 members of the `miscdevice` structure:\n\n1. `minor`: initialized as `MISC_DYNAMIC_MINOR`, so that the device gets a unique minor number on the fly.\n2. `name`: initialized as `DEVICE_NAME`, an alias to string `\"vulnerable_device\"`.\n3. `fops`: this field denotes a file/IO operation to be performed for this device.\n\nThe third ones seems interesting. What is its type? Find the type of the third field initialized with `&vuln_fops` by completing [Exercise7.ql](exercises/Exercise7.ql).\n\n<details>\n<summary>Hints</summary>\n\n- The class `Struct` inherits the member predicate `getAMember` from the class `Class` that gets the zero-based indexed member declared in the struct.\n- The class `Field` inherits the member predicate `getType` from the class `MemberVariable` that returns the type of the field.\n- Relate the QL expressions as much as possible. Relate the third field of the `misc_device` struct to its field with a suitable predicate, then associate the field to its type with another predicate. `Select` the type.\n\n</details>\n","topics":"Reasoning about the Driver Definition"},{"id":"LDF/101/cpp/06-putting-it-all-together","title":"Putting it all together","body":"\nWe are almost there and we have all the necessary QL definitions to be assembled into a complete query! Now we refactor our code first, and then connect every bit together to complete this workshop.\n\n### Exercise 10\n\nWe have successfully identified the miscellaneous driver definition (`miscdevice`), the file operations definition (`vuln_ops`), and linked the ioctl handler (`do_ioctl`) to the definition of type `file_operations`. Now, we would like to include the act of getting the `file_operation` of `struct miscdevice` under the class which expresses that very `struct miscdevice`, much like encapsulation in object-oriented languages.\n\nGet the class `MiscDeviceStruct` that represents `struct miscdevice` we wrote at Exercise 5, and add a [member predicate](https://codeql.github.com/docs/ql-language-reference/types/#member-predicates) `getFileOperations` that returns a `FileOperationsDefinition` that the miscellaneous driver definition is initialized with in [Exercise10.ql](exercises/Exercise10.ql).\n\n<details>\n<summary>Hints</summary>\n\n- The class `Variable` has the member predicate `getAnAssignedValue` that returns an `Expr` representing an expression that is assigned to this variable somewhere in the program.\n- The class `Field` inherits the member predicate `hasName` from the class `Declaration` that holds if the field has the provided name.\n- The class `ClassAggregateLiteral` has the member predicate `getFieldExpr` that returns an `Expr` that is part of the aggregate literal that is used to initialize the provided field.\n- A class can be cast to a subclass using the syntax `variable.(Class).predicate()`. For example, to cast an expression `expr` to a `AddressOfExpr` to get an operand of the expression you can use the syntax `expr.(AddressOfExpr).getOperand()`.\n- The class `AddressOfExpr` that represents the expression taking the address `&expr` has a member predicate `getOperand` that returns the expression of which the address is taken.\n- The class `Variable` has a member predicate `getAnAccess` that returns all the access to this variable.\n\n</details>\n\n### Exercise 11\n\nLet's put everything together we've done so far by weaving these classes into one:\n\n1. `MiscRegisterFunction`,\n2. `MiscDeviceDefinition`, and\n3. `FileOperationsDefinition`.\n\nAs a result, we will be able to chain the program elements from the misc_register function call, all the way to `do_ioctl` function.\n\nImplement the characteristic predicate for the class `MiscDriverUserModeEntry` in [Exercise11.ql](exercises/Exercise11.ql) that relates the classes `MiscRegisterFunction`, `MiscDeviceDefinition`, and `FileOperationsDefinition` such that its covers the call to `misc_register` and all the way to the definition of `do_ioctl`.\n\n<details>\n<summary>Hints</summary>\n\n- The class `Function` has a member predicate `getACallToThisFunction` that returns all the function call to this function.\n- The class `FunctionCall` inherits the member predicate `getArgument` from the class `Call` that returns the nth argument for this call.\n- A class can be casted to a subclass using the syntax `variable.(Class).predicate()`. For example, to cast an expression `expr` to a `AddressOfExpr` to get an operand of the expression you can use the syntax `expr.(AddressOfExpr).getOperand()`.\n- The class `Variable` has a member predicate `getAnAccess` that returns all the access to this variable.\n\n</details>\n\nNow, we can run this final query that successfully identifies the vulnerable function. Is the result as described?\n","topics":"Putting it all together"},{"id":"LDF/101/cpp/07-conclusion","title":"Conclusion","body":"\nIn this workshop, we have seen how QL represents a program as a queryable AST that can be effectively used for reasoning about various program elements in relation to others as well as identifying them, and using only those to identify a vulnerable function.\n\nWe have also learned how to express conditions in a reusable manner by leveraging the object-oriented type system of QL, through refactoring our code into predicates and classes.\n","topics":"Conclusion"},{"id":"LDF/101/cpp","title":"Elements of Syntactical Program Analysis I for C/C++","body":"\n## Introduction\n\nAn Abstract Syntax Tree (AST) is a representation of a given program that exposes its syntactic structure. The AST is much like a parse tree, but more concise and to-the-point, which makes it a convenient tool to investigate into simple topics such as whether the program contains a certain element, up to more complex ones such as whether it follows a certain structural pattern. These properties are static by nature, so these analyses provide high precision.\n\nWe learn how to query the AST of a C program and refactor it along the way by investigating a buffer overflow vulnerability in a sample Linux driver. We first start by identifying the point where the program inserts a driver definition to the kernel by using one of its APIs, and climb up the dependency chain by finding definitions and initializations of the types and objects used in the program. Finally, we reach the vulnerable function in question.\n\nBy following through the workshop, we:\n\n- Discover how QL represents C/C++ program elements.\n- Learn how to Query program elements in the AST ([Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)).\n- Learn how to express descriptions of certain program elements using QL classes.\n","topics":"syntactical, C, AST, buffer-overflow, linux"},{"id":"LDF/101","title":"LDF-101 - Elements of Syntactical Program Analysis I","body":"\n## Workshop Description\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\nincididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat\nblandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque\nviverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus\ndictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis\nlectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus\nfeugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra\nvitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et\nsollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum\nat varius vel.\n","topics":"LDF-101 - Elements of Syntactical Program Analysis I"},{"id":"LDF/101/python","title":"Elements of Syntactical Program Analysis I for Python","body":"\n## Introduction\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Blandit volutpat maecenas volutpat blandit. Ut morbi tincidunt augue interdum. Cursus eget nunc scelerisque viverra. Et tortor consequat id porta nibh venenatis cras sed felis. Ante metus dictum at tempor commodo ullamcorper. Aliquam purus sit amet luctus venenatis lectus magna. Amet consectetur adipiscing elit ut aliquam purus sit. Risus feugiat in ante metus. Nulla facilisi nullam vehicula ipsum. Augue lacus viverra vitae congue. Erat pellentesque adipiscing commodo elit. In fermentum et sollicitudin ac orci phasellus egestas tellus. Eu augue ut lectus arcu bibendum at varius vel.\n\nWrite a thing that can work through the list of things and do a thing.\n","topics":"Elements of Syntactical Program Analysis I for Python"},{"id":"LDF","title":"Language Dependent Features","body":"\n## Overview\n\nThe Language Dependent Features Workshops are a new set of workshops designed to\nprovide participants with a comprehensive understanding of the language-specific\naspects of CodeQL. The workshops cover fundamental concepts such as data-flow\nanalysis, taint tracking, and syntax analysis. These language-dependent aspects\nof CodeQL are essential for understanding how to effectively write code queries\nthat are tailored to specific programming languages. For instance, taint\ntracking is used to identify data that has been modified by an untrusted source\nin web applications. Participants will learn how to use taint tracking to\nimprove the security of web applications written in languages such as PHP,\nJavaScript, and Python.\n\nThe Language Dependent Features Workshops provide participants with a thorough\nunderstanding of the extensions of CodeQL in the form of a standard library\nwritten in the QL language. The standard library provides a set of predefined\npredicates that can be used to query and analyze code in a specific language.\nFor example, in C++, the standard library provides predicates to analyze virtual\nfunctions, class inheritance, and exception handling. In Java, the standard\nlibrary provides predicates to analyze reflection, inner classes, and anonymous\nclasses. By mastering the standard library of a specific language, participants\nwill be able to write more sophisticated queries that leverage the\nlanguage-specific features of CodeQL.\n\nOverall, The Language Dependent Features Workshops are an excellent resource for\ndevelopers looking to gain a comprehensive understanding of CodeQL. By mastering\nlanguage-dependent aspects such as data-flow analysis, taint tracking, and\nsyntax analysis, participants will be able to write more sophisticated queries\nthat can identify complex security vulnerabilities and improve code quality.\nFurthermore, the workshops provide participants with the knowledge needed to\neffectively use the extensions of CodeQL provided by the standard library,\nenabling them to write more powerful queries that can analyze the intricacies of\nspecific programming languages.\n","topics":"Language Dependent Features"},{"id":"QLC/100/01-introduction","title":"Introduction","body":"\nThis workshop provides a tour of CodeQL, discussing the tooling and\nthe QL language.\n","topics":"Introduction"},{"id":"QLC/100/02-setting-up-your-development-environment","title":"Setting up your development environment","body":"\nBefore we start we are going to spend some time to setup the development environment because that is essential for you to participate in the workshop.\n\nThe development environment will consist of:\n\n- [Visual Studio Code](https://code.visualstudio.com/)\n- The [CodeQL](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql) extension\n- The [CodeQL CLI](https://github.com/github/codeql-cli-binaries/releases/latest)\n\nFollow the next steps to set up your environment. Feel free to reach out for support if things aren't going as planned.\n\n1. Ensure you have the latest Visual Studio Code installed by downloading it from the [download page](https://code.visualstudio.com/Download) for your operating system and install it by following the [setup](https://code.visualstudio.com/docs/setup/setup-overview) instructions.\n2. Install the CodeQL extension from the [Extension Marketplace](https://code.visualstudio.com/docs/editor/extension-marketplace).\n\nThe CodeQL extension automatically installs and updates the CodeQL CLI. However, the extension managed CLI is inconvienient to use directly in a Visual Studio Code terminal or other terminal available on your system due to the isolation mechanisms applied to Visual Studio Code extensions. We want to directly use the CodeQL CLI for the tasks that haven't been made available through the CodeQL extension, such as create QL packs and building databases. No worries if that doesn't ring a bell yet. These topics will be discussed in this workshop.\n\nTo install the CodeQL CLI and configure the Visual Studio Code extension use the following steps. We have split up the instructions for those that have the [GitHub CLI](https://cli.github.com/) installed and [authenticated](https://cli.github.com/manual/gh_auth_login) and for those who don't.\n\n1. Install the CodeQL CLI with the GitHub CLI (GH)\n\n    For those that have GH you can install the CodeQL extension to manage CodeQL CLI installations:\n\n    ```bash\n    # Install the CodeQL extension\n    gh install codeql\n\n    # Install a CodeQL stub for use with the Visual Studio Code extension. Default directory is /usr/local/bin.\n    # For convenience, make sure the chosen path is added to your path environment variable.\n    # For Linux and MacOS, add it to the $PATH environment variable.\n    # For Windows, add it to the %PATH% environment variable.\n    gh codeql install-stub\n\n    # Install the latest version\n    gh codeql set-version latest\n    ```\n\n2. Install the CodeQL CLI manually\n\n    To manually install the latest CodeQL CLI download the archive corresponding to your operating system from the [release](https://github.com/github/codeql-cli-binaries/releases/latest) page. Unzip the archive to a location of choice, then make sure that location is added to your path environment variable. For Linux and MacOS, add it to the `$PATH` environment variable. For Windows, add it to the `%PATH%` environment variable.\n\n3. Verifying your CodeQL CLI setup\n\n    The CodeQL CLI has subcommands that can help with verify that the CLI is correctly set up.\n\n    Run the following command to show which languages are available for database creation.\n\n    ```bash\n    codeql resolve languages\n    ```\n\n    For the purpose of this workshop make sure that the `cpp` language is available.\n\n4. Configuring the CodeQL extension\n\n    With the CodeQL CLI installed we are going to configure the CodeQL extension to use the installed extension.\n\n    Locate the setting `codeQL.cli.executablePath` in the [user and workspace settings](https://code.visualstudio.com/docs/getstarted/settings) and update it to the absolute path of the CodeQL CLI executable if is not part of your system's path environment or just `codeql` (`codeql.exe` for Windows). The extension will notify you of any problems in case of a misconfiguration.\n","topics":"Setting up your development environment"},{"id":"QLC/100/03-preparing-your-first-ql-query","title":"Preparing your first QL query","body":"\nWith the development environment set up we can start with writing your first\nquery. For this workshop, you will need to clone the repository `https://github.com/codeql-workshops/codeql-learning-catalog` and save your work in the\n`docs/QLC/100/src/problems` directory.\n\n```bash\ngit clone https://github.com/codeql-workshops/codeql-learning-catalog\n```\n\nAfter cloning the repository open the folder in Visual Studio Code.\n\nBefore we can write our actual query we need to create a [CodeQL pack](https://codeql.github.com/docs/codeql-cli/creating-and-working-with-codeql-packs/). A CodeQL pack is a unit of queries or libraries that can be shared. CodeQL pack also provides the necessary information to CodeQL to run a query part of that pack.\n\nLet's start with switching to the workshop directory to store our the workshop assets.\n\nIn Visual Studio Code, open the [integrated terminal](https://code.visualstudio.com/docs/terminal/basics) and run the following commands to create a CodeQL pack.\n\n```bash\ncd docs/QLC/100/\ncodeql pack init qlc-100/problems -d src\n```\n\nThis will create a subdirectory of `src` named `qlc-100/problems` which will contain the file `qlpack.yml` with the following contents:\n\n```yaml\n---\nlibrary: false\nname: qlc-100/problems\nversion: 0.0.1\n```\n\nThe `qlpack.yml` describes the metadata of a CodeQL pack through properties. A description of the properties can be found [here](https://codeql.github.com/docs/codeql-cli/about-codeql-packs/#qlpack-yml-properties). For now we start with this minimal CodeQL pack specification that states it is a query pack, as opposed to a library pack, via the key `library: false`. The difference will be become apparent when you publish a package. A query pack, when published, will include all its dependencies and a precompiled version of the queries to ensure a fast deployment and evaluation.\n\nWith the query pack set up we are going to create another query pack to hold our tests. CodeQL provides testing infrastructure to create system agnostic unit tests for your queries. System agnostic means that it will not depend on external dependencies and that the tests will provide the same results on different operating systems with different compilers/interpreters and libraries installed.\n\n```bash\ncodeql pack init --extractor cpp qlc-100-tests/problems -d tests\n```\n\nThis will generate a file (`qlpack.yml`), similar what we have seen before, with an additional property `extractor` set to the value `cpp`. Normally the target language is specified by the database, because a database can only target a single language. With the `extractor` property we inform the testing infrastructure to use the C/C++ extractor to create test databases to validate our queries.\n\nTo test a query in the `qlc-100/problems` CodeQL pack we need to inform the `qlc-100-tests/problems` CodeQL pack how to resolve that query. This can be achieved through the `dependencies` property.\n\nChange the `qlpack.yml` to match the following contents.\n\n```yaml\n---\nlibrary: false\nname: qlc-100-tests/problems\nversion: 0.0.1\nextractor: cpp\ndependencies:\n  \"qlc-100/problems\": \"*\"\n```\n\nA dependency is resolved by the CodeQL pack name and a version. While our query CodeQL pack has version `0.0.1` we specify the `*` value to direct the CodeQL package manager to consider a local version of the query pack before reaching out to the package registry to download the latest version.\n\nWith our query and test CodeQL pack up and running we can run the command `codeql pack ls` to list the CodeQL packs that the CodeQL CLI can resolve.\n\n```bash\n▶ codeql pack ls\nRunning on packs: qlc-100-tests/solutions, qlc-100/solutions.\nFound qlc-100/solutions@0.0.1\nFound qlc-100-tests/solutions@0.0.1\n```\n\nThe command doesn't list our just created problem packs. The\n`codeql-workspace.yml` files helps the CodeQL CLI resolve CodeQL packs when\nmultiple are defined in a project.\n\nOpen the file `codeql-workspace.yml` in `docs/QLC/100` and ensure it has the\nfollowing content by adding the item `\"*/problems/qlpack.yml\"`:\n\n```yaml\nprovide:\n  - \"*/solutions/qlpack.yml\"\n  - \"*/problems/qlpack.yml\"\n```\n\nWith the CodeQL workspace re-running the `codeql pack ls` command succeeds.\n\n```bash\n▶ codeql pack ls\nRunning on packs: qlc-100-tests/problems, qlc-100/problems, qlc-100-tests/solutions, qlc-100/solutions.\nFound qlc-100/problems@0.0.1\nFound qlc-100-tests/problems@0.0.1\nFound qlc-100/solutions@0.0.1\nFound qlc-100-tests/solutions@0.0.1\n```\n\nThe `provide` key holds an array of path patterns for CodeQL pack files (i.e., `qlpack.yml` files) that this directory provides. A CodeQL workspace can be considered a container for multiple CodeQL packs. Path patterns allow lightweight globbing where each path component can be a `*`: matching any path component, or `**`: matching multiple arbitrary path components. The latter is useful if your projects contains multiple CodeQL packs organized per category, for example per language. Then the CodeQL workspace file can contain a path pattern per category. For example:\n\n```yaml\nprovide:\n  - \"cpp/**/qlpack.yml\"\n  - \"java/**/qlpack.yml\"\n```\n\ncan be used for the directory tree:\n\n```yaml\n- cpp /\n  - github\n    - security-queries\n  qlpack.yml\n    - security-tests\n  qlpack.yml\n    - security-libs\n  qlpack.yml\n- java /\n  - github\n    - security-queries\n  qlpack.yml\n    - security-tests\n  qlpack.yml\n    - security-libs\n  qlpack.yml\n```\n","topics":"Preparing your first QL query"},{"id":"QLC/100/04-writing-your-first-query","title":"Writing your first QL query","body":"\nNow that we have created our query and test CodeQL packs we can finally start with our first query!\n\nCreate the file `HelloWorld.ql` in the `qlc-100/problems` CodeQL pack with the following content:\n\n```c file=./src/solutions/HelloWorld.ql\n```\n\nThat is it for our first query. To determine if it works as intended we want to test it so we should add a unit test to our `qlc-100-tests/problems` CodeQL pack.\n\n1. Create a folder `HelloWorld` in the `qlc-100-tests/problems` directory.\n2. Add the file `HelloWorld.qlref` in the just created directory `HelloWorld` with the contents:\n\n    ```c file=./tests/solutions/HelloWorld.qlref\n    ```\n\n3. Add the file `HelloWorld.expected` in the just created directory `HelloWorld` with the contents:\n\n    ```c file=./tests/solutions/HelloWorld.expected\n    ```\n\nThe `HelloWorld.qlref` is a query reference file that references to a query to be tested. It is a path relative to a CodeQL pack.\n\n<details><summary>How does CodeQL know which CodeQL pack?</summary>\n\nCodeQL will go through the dependencies to determine which CodeQL pack contains the query.\n\n</details>\n\nInstead of a query reference file you can also specify a query file directly. However, it is common to separate them into their own CodeQL packs so they can be independently be published and deployed.\n\nThe `HelloWorld.expected` file contains the expected output when running the query on a database built from files residing in the `HelloWorld` directory. In our case we have none, so the database will be empty.\n\nWith the qlpack specification for the test we can run the test using the [Test Explorer UI](https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-test-explorer) extension that is installed as a dependency of the CodeQL extension.\n\n![img](/assets/images/QLC/100/test-explorer-ui-extension.png \"The HelloWorld test listed in the Test Explorer UI\")\n\nWe can run the test from the Test Explorer UI or run the test from the terminal with the command:\n\n```bash\ncodeql test run tests/problems/HelloWorld\n```\n\nEither way, running the test will result in the error:\n\n```bash\nError: Could not locate a dbscheme to compile against.\nYou probably need to specify a libraryPathDependencies list in\n/.../src/qlpack.yml\n```\n\nThe test is unable to determine the database schema to our query in the `qlc-100/problems` CodeQL pack. Every CodeQL database adheres to a language specific database schema and every query should adhere to the same schema so it can correctly query the database. The database schema for queries (as supposed to the extractor creating the database) is located in the standard library `all` pack of the language we want to query.\n\nWhile we remain language agnostic with the queries discussed in this workshop, we still need to pick a language for the database schema. Adjust the `qlpack.yml` of the `qlc-100/problems` CodeQL pack to match the following content:\n\n```yaml\n---\nlibrary: false\nname: qlc-100/problems\nversion: 0.0.1\ndependencies:\n  \"codeql/cpp-all\": \"*\"\n```\n\nTo ensure the dependency is available we need to run the command:\n\n```bash\n▶ codeql pack install qlc-100/problems\nDependencies resolved. Installing packages...\nInstall location: /.../.codeql/packages\nPackage install location: /.../.codeql/packages\nAlready installed codeql/cpp-all@0.4.3 (library)\n```\n\nThrough the `qlc-100/problems` CodeQL pack the `qlc-100-tests/problems` CodeQL pack has a dependency on `codeql/cpp-all` as well. So we need to resolve those dependencies by running the command:\n\n```bash\n▶ codeql pack install qlc-100-tests/problems\nDependencies resolved. Installing packages...\nInstall location: /.../.codeql/packages\nPackage install location: /.../.codeql/packages\nAlready installed codeql/cpp-all@0.4.3 (library)\n```\n\nWith all the dependencies resolved we can re-run the test. Try running both from Testing Explorer UI and using the CodeQL CLI.\n\nCongrats, you have written your first query!\n","topics":"Writing your first QL query"},{"id":"QLC/100/05-the-structure-of-ql-query","title":"The structure of a QL query","body":"\nOur first query didn't provide a lot of information around the structure of a QL query besides the use of the `select` keyword.\n\nA typical query contains the following elements:\n\n- Query metadata.\n- Import statements\n- Definitions of classes and predicates\n- The `from`, `where`, and `select` clause.\n\nLet start exploring these components from the bottom up.\n\n1. The `select` clause\n\n    For those familiar with query languages such as SQL the syntax of the `select` clause, consisting of the two optional `from` and `where` parts and the mandatory `select` part, should look familiar.\n\n    ```ql\n    from ...\n    where ...\n    select ...\n    ```\n\n    The `from` part can be used to declare variables. Each variable represents a set of values of the same sort described by the variable's type. Because sets of values can overlap (that is, their intersection is not empty) it can be the case that values have multiple types.\n\n    <details><summary>Can you think of an example of a value in a program that would be described by multiple types?</summary>\n\n    For example, a type representing all the expressions in a program and a type representing all the arithmetic expressions in a program.\n\n    </details>\n\n    The following examples describe types and the values they represent.\n\n    - The primitive type `int` with each value being a 32-bit two's complement integer.\n    - The primitive type `string` with each value being a finite sequence of 16-bit characters, each interpreted as a Unicode code point.\n    - The class `Expr` with each value being an expression in a program (part of the database being queried).\n\n    Note that in the last example we used the term *class* instead of *type*. In QL you can define your own *type* by defining a *class*.\n\n    To reason about the variables and their values we can further restrict the values of the variables in the `where` part.\n\n    QL is a *logic programming language* and is built up of logical formulas. In the `where` part we can use formulas to define logical relations between expressions and are of the form `<expr> <op> <expr>`. Wait, didn't we discussed variables instead of expressions?\n\n    [Expressions](https://codeql.github.com/docs/ql-language-reference/expressions/) evaluate to a set of values.\n\n    <details><summary>What determines the set of values?</summary>\n\n    The set of values an expression evaluates to is determined by a type.\n\n    </details>\n\n    During query writing we will get introduced to the many kinds of expressions. For now we will continue with variables. In a formula a variable can be referenced using a *[variable reference](https://codeql.github.com/docs/ql-language-reference/expressions/#variable-references)*.\n\n    Finally, we have the [select clause](https://codeql.github.com/docs/ql-language-reference/queries/#select-clauses) that determines what we want to *select* as a result for the query. The result of a query will be a set of ordered tuples commonly represented as a table with columns and rows. The columns are determined by the expression provided to the `select` clause. The provided *expressions* **must** evaluate to a value part of a *primitive type*. We will discuss what *primitive types* later on in this workshop. Classes have a *member predicate* `toString` that is used to convert them to a `string`.\n\n    The `as` keyword can be used to label to a column of results and allows the result to be referenced in other expressions part of the select clause. The `order by` keyword allows you to sort the result set. To control the ordering you can use the keywords `asc`, for ascending, and `desc` for descending.\n\n    Let's have a look at some concrete examples!\n\n    1. Add the query `FromWhereSelect.ql` to the CodeQL pack `qlc-100/problems` with the following contents\n\n        ```ql file=./src/solutions/FromWhereSelect.ql\n        ```\n\n    2. Add a directory `FromWhereSelect` with the files `FromWhereSelect.qlref` and `FromWhereSelect.expected` to the CodeQL pack `qlc-100-tests/problems`. Make sure to add the path `FromWhereSelect.ql`, the path to the query relative to the CodeQL pack it belongs to, in the `FromWhereSelect.qlref` file.\n\n    3. Run the newly created QL test.\n\n    The test will fail and output the following result.\n\n    ```diff file=./tests/solutions/FromWhereSelect.expected\n    ```\n\n    <details><summary>Why did the test fail?</summary>\n\n    The output of the query didn't match our test's expected file.\n\n    </details>\n\n    For each test that fails, the CodeQL extension keeps the database so we can investigate why the test failed. In the directory `FromWhereSelect` there should be an additional directory named `FromWhereSelect.testproj`. You can mount the test database with the command `CodeQL: Set Current Database` that is available in the context menu when you right click on the directory `FromWhereSelect.testproj` in the Visual Studio Code file explorer.\n\n    ![img](/assets/images/QLC/100/mount-testproj.png \"Select the failed test database as the current database.\")\n\n    To investigate a failed test you can make use of the `CodeQL: Quick query` functionality. This allows you to quickly create a one-off query for a mounted database.\n\n    To test this, perform the following steps:\n\n    1. Mount the `FromWhereSelect.testproj` database.\n    2. Execute the command `CodeQL: Quick Query` using the Visual Studio Code [Command Palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette). Answer with Yes when prompted to reload the workspace as a multi-folder workspace, and yes when prompted to trust the workspace.\n\n    In the Visual Studio Code Explorer you can now find a new folder named `Quick Queries` with, among others, a file `quick-query.ql` with the contents\n\n    ```ql\n    import cpp\n\n    select \"\"\n    ```\n\n    ![img](/assets/images/QLC/100/quick-query-folder.png \"Quick query folder added to the workspace\")\n\n    The contents of the `quick-query.ql` file has been setup to match the language of your selected database. The language can also be seen in the database section of the CodeQL extension.\n\n    ![img](/assets/images/QLC/100/codeql-databases-section.png \"CodeQL extension databases section\")\n\n    The query can be executed using the command `CodeQL: Run Query` via the Command Palette or the right-click menu.\n\n    Once you have established why the test cased failed, and corrected your query you can re-run the test. If you start with an empty `FromWhereSelect.expected` file you can accept the test output via the right-click menu that is available on the test or run the CodeQL CLI command `codeql test accept tests/problems/FromWhereSelect/FromWhereSelect.qlref`.\n\n    ![img](/assets/images/QLC/100/accept-test-output.png \"Accept test output\")\n\n2. Imports\n\n    QL supports [modules](https://codeql.github.com/docs/ql-language-reference/modules/#modules) to organize and reuse QL code. Each query file, with the extension `.ql`, and library file, with the extension `.qll`, *implicitly* defines a module. The `import` statement can be used to import public names (i..e, not annotated [private](https://codeql.github.com/docs/ql-language-reference/annotations/#private)), of a library module, into the namespace of the current module containing the `import` statement.\n\n    By convention the first statement in a query module is the import of the language library you are targeting. For example, `import cpp`.\n\n    Modules will not be further discussed in this quick-start.\n\n3. Query metadata\n\n    A query has properties that provide information to users of a query and provides information to consumer of the query result on how to display its results. These properties are known as query metadata.\n\n    The query metadata resides at the top in a query file as a [QLDoc comment](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#qldoc-qldoc). A QLDoc comment starts with a `/**`, ends with a `*/`, and can span multiple lines. The body of QLDoc, the *contents*, is compromised of all the text surrounded by~/\\*\\*~ and `*/`. For each line the leading whitespace followed by a `*` is ignored and excluded from the content. The [contents](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#content) is interpreted as [CommonMark](https://commonmark.org/). The properties of a query are specified as tags. A tag is started with a `@` sign followed by any number of non-whitespace characters to form the *key* of the tag. A single whitespace character separates the key from the value, with the value being the remainder of the line.\n\n    The supported properties of a query can be found [here.](https://codeql.github.com/docs/writing-codeql-queries/metadata-for-codeql-queries/#metadata-properties) The next snippet shows the metadata for a standard library query.\n\n    ```ql\n    /**\n    * @name Uncontrolled data used in OS command\n    * @description Using user-supplied data in an OS command, without\n    *              neutralizing special elements, can make code vulnerable\n    *              to command injection.\n    * @kind path-problem\n    * @problem.severity error\n    * @security-severity 9.8\n    * @precision high\n    * @id cpp/command-line-injection\n    * @tags security\n    *       external/cwe/cwe-078\n    *       external/cwe/cwe-088\n    */\n    ```\n\n    Here are a few takeaways for query metadata when consuming the results in GitHub Code Scanning:\n\n    - A `@name` property is **required** and defines a display name for the query. The [metadata style guide](https://github.com/github/codeql/blob/master/docs/query-metadata-style-guide.md#query-name-name) prescribes you should use sentence capitalization without a full stop.\n    - A `@description` property is **required** and defines a short help message. The [meta data style guide](https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md#query-descriptions-description) prescribes you should be written as a sentence or a short paragraph with sentence capitalization and a full stop.\n    - A `@id` property is **required**. The id must uniquely identify a query and *should* follow the CodeQL convention by starting the id with a *language code* followed by a `/`. The remainder of the id should consists of a short noun phrase. For example, `cpp/command-line-injection`. Additional terms can be added to group queries. For example, `js/angular-js/missing-explicit-injection` and `js/angular-js/dpulicate-dependency`. **Note: Code Scanning uses the id to track alerts, changing the id will result in alerts tracked with the old id being closed and new alerts with the new id being introduced.**\n    - A `@kind` property is **required**. There are multiple query types, but the most common alert kinds are: `problem` and `path-problem`. The kind property determines how to display the result of a query and expects a specific `select` form described in [Defining the results of a query](https://codeql.github.com/docs/writing-codeql-queries/defining-the-results-of-a-query/) and [Creating path queries](https://codeql.github.com/docs/writing-codeql-queries/creating-path-queries/#creating-path-queries).\n    - A `@precision` property is *optional* for alert queries and indicates the proportion of true positives expected for the query. Possible values are:\n        - `low`, expect a lot of false positives\n        - `medium`, expect a moderate number of false positives\n        - `high`, expect a low number of false positives\n        - `very-high`, expect false positives in exceptional cases\n    - A `@problem.severity` property is *optional* for alert queries and indicates the severity for alerts. Possible values are:\n        - `error`, an issue that likely results in incorrect program behavior such as a crash or vulnerability\n        - `warning`, an issue indicating a potential problem and could become a problem due to changes in the code.\n        - `recommendation`, an issue that indicates code behaves correctly, but could be improved.\n    - A `@tags` property is *optional*. Tags can be used to group queries into categories for identification purposes. The common tags are: `correctness`, `maintainabilility`, `readability`, `security`. Other known uses cases are to tag a query with a known weakness classification such as a [CWE](https://cwe.mitre.org/) or [OWASP Top 10](https://owasp.org/Top10/). Our standard queries, for example, use a CWE tag like `external/cwe/cwe-119`.\n        - An additional `@security-severity` property is available for queries with `security` tag. This defines a severity with the range `0.0` - `10.0`. The blog [CodeQL code scanning: new severity levels for security alerts](https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/) describes how to compute a severity.\n\n    The query properties can be used to filter which queries are part of a [CodeQL query suite](https://codeql.github.com/docs/codeql-cli/creating-codeql-query-suites/#filtering-the-queries-in-a-query-suite). This won't be discussed in this quick-start.\n","topics":"The structure of a QL query"},{"id":"QLC/100/06-the-essence-of-a-ql-query","title":"The essence of a QL query","body":"\nWith a basic understanding of the structure of a query we can continue looking at the building blocks of queries, namely *types*, *expressions*, *formulas*, and *predicates*.\n\nIn essence, a query is about relating types and their values. By solving a logic puzzle we are going to learn more about the building blocks and how they can be used.\n\n### Predicates\n\nLet's start with a simple logic puzzle. There are five racers named `A`, `B`, `C`, `D`, and `E`. Each finish the race as follows:\n\n- `C` finishes before `B`, but not before `D`\n- `E` finishes before `A`, but not before `B`\n\nWhat is the finish order?\n\nWe have a relation between racers that determines who finishes before another racer. How can we capture such a relation?\n\nLet's start with a first attempt where we use integers combined with comparison expressions. Create the query file `PuzzleOneAttemptOne.ql` and the corresponding QL test files in the directory `PuzzleOne`.\n\n```ql file=./src/solutions/PuzzleOneAttemptOne.ql\n```\n\nWhen we run this query we get the following results.\n\n```diff file=./tests/solutions/PuzzleOneAttemptOne.expected\n```\n\nRepresenting the correct result `D` `C` `B` `E` `A`.\n\nHowever, the query doesn't seem very *elegant*. We have to manually construct the final result. What if we add more racers, lets say up to a total of 1024? That would become very unwieldy. We need a better way to capture the relation between two racers.\n\nIn logic, a *predicate* represents a property or relation. QL, being a logical language, supports predicates. Create the query file `PuzzleOneAttemptTwo.ql` and the corresponding QL test files. In the query file define the predicate `finishesBefore` that captures the relation between the racers.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoA.ql\n```\n\nRun the `PuzzleOneAttemptTwo.qlref` test and mount the test database `PuzzleOne.testproj` of the failed test. Note that the test database has the name of the test directory, because the parent directory of each `.qlref` file is used to construct a test database.\n\nWith the test database mounted we can now test our predicate `finishesBefore` with quick evaluation. The Visual Studio Code editor will provide hints as to what can be quick evaluated.\n\n![img](/assets/images/QLC/100/quick-evaluation.png \"Quick evaluating hint on `finishesBefore` predicate.\")\n\nThe result of quick evaluating the `finishesBefore` predicate should match:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwoA.expected\n```\n\nThe quick evaluation functionality is super useful when debugging your logic. Besides the hints provided by Visual Studio Code you can also select *formulas*, *expressions*, and *types* and quick evaluate them with a right-click to access the `CodeQL: Quick Evaluation` command.\n\n![img](/assets/images/QLC/100/partial-quick-evaluation.png \"Quick evaluating the first two disjunctions.\")\n\nTo find the finish order we want to *connect* the tuples created by the predicate `finishesBefore`. For example, `(D, C)` and `(C, B)` to get a partial finish order `(D,C,B)`. That is, the second argument in one predicate call becomes the first argument in another call.\n\n<details><summary>Implement a query to find the partial finish order `D C B` using the `finishesBefore` predicate.</summary>\n\n```ql\nfrom string one, string two, string three\nwhere one = \"D\" and finishesBefore(one, two) and finishesBefore(two, three)\nselect one, two, three\n```\n\n</details>\n\nThe solution works well for this partial finish order, but we are back to representing each of the racers as a variable and having to make multiple predicate calls to get the complete finish order.\n\nThis repeated connecting of predicate calls is a common pattern in reachability problems and are typically concerned with whether one location can reach another location given a step function. More concrete examples are:\n\n- Can function `foo` reach function `bar` through function calls?\n- Can the value of variable `foo` reach argument `bar` of function `baz`?\n\nWe can treat the finish order problem as a reachability problem by finding the path from the first finisher to the last.\n\nQL supports the repeated application of a predicate through recursion. In a recursive predicate we have to consider two cases:\n\n1. The base case, which determines when we are done.\n2. The recursive case\n\nThe following example demonstrates how recursion can be used to find all the finishers after a certain finisher. Note that we renamed the predicate `finishesBefore` to `finishesBeforeStep` to highlight it is a step function.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoB.ql#L1-L17\n\n```\n\nThe base case is our step predicate `finishesBeforeStep`, finding all the finishers reachable with a single step. The recursive case uses the [quantified formula](https://codeql.github.com/docs/ql-language-reference/formulas/#quantified-formulas) [exists](https://codeql.github.com/docs/ql-language-reference/formulas/#exists). Quantified formulas allow us to introduce temporary variables that we can use in the formula's body to create new formulas from existing ones. The `exists` formula has the syntax `exists(<variable declarations> | <formula>)`. The syntax used in our example, `exists(<variable declarations> | <formula1> | <formula2>)`, is equivalent to `exists(<variable declarations> | <formula1> and <formula2>)`.\n\nWe use the `exists` to create a new formula from the predicate `finishesBeforeStep` and the predicate `finishesBefore` to find another racer that we can reach with a single step and all the racers that reachable from that other racer.\n\nQuick evaluating the new `finishesBefore` predicate provides us with the result:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwoB.expected\n```\n\nBecause this type of recursion is very common QL has implemented a shortcut that computes a [transitive closure](https://codeql.github.com/docs/ql-language-reference/recursion/#transitive-closures) of a predicate. The transitive closure is obtained by repeatedly calling a predicate.\n\nQL has two types of transitive closures. The transitive closure `+` that calls a predicate one ore more times. The reflexive transitive closure `*` calls a predicate zero or more times. The transitive closure of a predicate call can be used by appending a `+` or a `*` to the predicate name in a predicate call.\n\nUsing our step function we can compute the transitive closure by calling it as `finishesBeforeStep+(racerOne, racerTwo)`.\n\nThe transitive closure cannot be used on all predicate calls. The predicate must have two arguments with types that are [compatible](https://codeql.github.com/docs/ql-language-reference/types/#type-compatibility).\n\n<details><summary>Write a query that uses the transitive closure of the predicate `finishesBeforeStep` to compute the same results as the recursive predicate `finishesBefore`.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoC.ql#L11-L14\n\n```\n\n</details>\n\nTo determine if the results are the same you can use the `Compare Results` option in the `Query History` pane of the CodeQL extension.\n\nSelect to last two items in the history, right-click, and select `Compare Results`. This should result in an empty comparison.\n\n![img](/assets/images/QLC/100/compare-results.png \"Compare query results\")\n\nWith our transitive closure we are almost done with finding the finish order. First we want to limit the reachable racers from the first finisher. Secondly we want a single answer.\n\nLet's continue with determining which racer is the first to finish.\n\n<details><summary>How can you determine who is the first finisher?</summary>\n\nThe first finisher is a finisher with no finisher before them. That is, it is not the case there exists another finisher that finishes before the first one.\n\n</details>\n\nIn QL you can negate a formula by prepending a `not` to that formula. For example, the following query returns all pairs where `racerOne` does not finish before `racerTwo`.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoD.ql#L11-L16\n```\n\nThe extra equality expressions for `racerOne` and `racerTwo` are required because we can't determine the range of values for `racerOne` and `racerTwo` from a negation. That is, `not` is not [binding](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding). Without those the CodeQL will give an error that `racerOne` and `racerTwo` are not bounded to a value. This is caused by the fact that many of the primitive types including `string` are infinite. They have an infinite number of values. Since QL can only work with finite results we need to restrict the set of values for the result. Before, that was done by the `finishesBeforeStep` predicate.\n\nTo restrict the set of values we use the member predicate `charAt` that expects an index. We, however, are not interested in a particular index so we pass the [dont'-care expression](https://codeql.github.com/docs/ql-language-reference/expressions/#don-t-care-expressions). That is any value which will result in calling the predicate with all the indices binding the racers to the characters `[\"A\", \"B\", \"C\", \"D\", \"E\"]`. `racerOne = \"ABCDE\".charAt(_)` is equivalent to `racerOne = [\"A\", \"B\", \"C\", \"D\", \"E\"]` where the latter is the [set literal expression](https://codeql.github.com/docs/ql-language-reference/expressions/#set-literal-expressions) we used in the very beginning.\n\n<details><summary>Using the `not` formula, write a predicate `firstFinisher` that holds if a finisher is the first finisher. Remember, `not` is not [binding](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding).</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoE.ql#L11-L14\n```\n\n</details>\n\nWith the `firstFinisher` predicate we can now limit the results to the first finisher and all those that are reachable from the first finisher.\n\n<details><summary>Write a query that returns the first finisher and all the finisher reachable from that first finisher.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoF.ql#L16-L18\n```\n\n</details>\n\nSo now we have the first finisher and all those that finish after. However, there are still multiple results. The last task is to [aggregate](https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations) the finishers to get the final finish order.\n\nIn our case the aggregate `[[https://codeql.github.com/docs/ql-language-reference/expressions/#aggregations][concat]]` looks interesting, however, we can't properly control the order of the results which in this case is important.\n\nThat is, the following does not give the correct order because strings are sorted lexicographically.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoG.ql#L16-L20\n```\n\n<details><summary>Why does the query use the reflexive transitive closure operator `*`?</summary>\n\nTo include the `firstFinisher` that does not have a finisher before them.\n\n</details>\n\nThat means we need to build the final finish order ourselves, recursively. We have seen recursion and the closely related transitive closure before. In most cases the transitive closure is sufficient, but sometimes you want more control. For example when the goal is to find all the functions reachable from a function `entrypoint` that are not reachable by an authorization function to determine authentication bypasses.\n\nIn this case we want to build up the finish order from the first finisher. A recursive problem requires two cases, the base case, and the recursive case.\n\n<details><summary>The base case determines when we are done. What would that be in our problem?</summary>\n\nWhen we have reached the last finisher.\n\n</details>\n\n<details><summary>Implement the predicate `lastFinisher` using the already defined predicate `finishesBeforeStep`. You can take inspiration from the predicate `firstFinisher`. Remember that the `not` does not *bind*.</summary>\n\n```ql file=./src/solutions/PuzzleOneAttemptTwoH.ql#L16-L18\npredicate lastFinisher(string racer) {\n    not finishesBeforeStep(racer, _) and finishesBeforeStep(_, racer)\n}\n```\n\n</details>\n\n<details><summary>Write the predicate `finishOrderFor`. QL supports [predicates with results](https://codeql.github.com/docs/ql-language-reference/predicates/#predicates-with-result). A predicate with a result is defined by replacing the keyword `predicate` with the type of the result. The result can be referenced through a special variable `result`. Semantically it is the same as predicates without a result, the result would just be a parameter, but it can result in a more readable query because you can omit a `exists`.\n\n```ql\nstring finishOrderFor(string racer) {\n    none() // replace with implementation\n}\n```\n\n</summary>\n\nWith the predicate `finishesBeforeStep` rewritten as a predicate with a value, and the predicate `finishOrderFor` written as a predicate with a value, the complete query becomes.\n\n```ql file=./src/solutions/PuzzleOneAttemptTwo.ql\n```\n\nThe result of this query should be:\n\n```ql file=./tests/solutions/PuzzleOneAttemptTwo.expected\n```\n\n</details>\n","topics":"The essence of a QL query"},{"id":"QLC/100/07-conclusion","title":"Conclusion","body":"\nIn this quickstart we have:\n\n- setup a development environment,\n- looked at CodeQL packs for queries and tests,\n- learned about the structure of a query, and\n- used predicates to solve a logic puzzle.\n","topics":"Conclusion"},{"id":"QLC/100","title":"QLC 100 - QL Quickstart","body":"\n## Introduction\n\nThe QL Quickstart workshop is designed to provide participants with a\ncomprehensive introduction to the QL language used in CodeQL, with a focus on\nthe basics of setting up a development environment and writing QL queries. The\nworkshop covers several key topics, including setting up your development\nenvironment for CodeQL development, preparing to write your first QL query,\nwriting your first QL query, the structure of a QL query, and the essence of a\nQL query.\n\nDuring the first section of the workshop, participants will learn how to set up\ntheir development environment for CodeQL development. They will learn how to\ndownload and install CodeQL tools and set up their environment to work with the\nCodeQL query language. They will also learn about the basics of using CodeQL in\nthe context of a development environment, including how to navigate the\ninterface and run queries.\n\nIn the second section, participants will learn about the basics of preparing to\nwrite their first QL query. They will learn about the different types of queries\nthat can be used in CodeQL, including database queries, code queries, and result\nset queries. They will also learn about the structure of a QL query and the\ndifferent components that make up a query.\n\nIn the third section, participants will learn how to write their first QL query.\nThey will learn about the essence of a QL query and how to structure their code\nto achieve the desired results. They will also learn how to debug their code and\ntroubleshoot common errors that can arise when working with CodeQL. By the end\nof the workshop, participants will have a solid foundation in the QL language\nand will ready to study subsequent topics about the QL language.\n","topics":"QLC 100 - QL Quickstart"},{"id":"QLC","title":"QL Core","body":"\n## Overview\n\nThe QL language used in the CodeQL analysis platform is a domain-specific\nprogramming language that includes several powerful features that make it\nwell-suited for security analysis. Some of the key features of QL include\nclasses, predicates, modules, recursion, and types.\n\nClasses in QL allow programmers to define and group related data and methods\ntogether. This makes it easy to organize and manipulate data in a codebase.\nPredicates are another important feature of QL that allow programmers to define\nreusable queries for analyzing code. Predicates are similar to functions in\nother programming languages and can be called from other queries or predicates\nto build complex analysis pipelines.\n\nModules in QL provide a way to organize code and separate concerns. They allow\nprogrammers to break a large analysis task into smaller, more manageable pieces\nthat can be developed independently. Recursion is another powerful feature of QL\nthat allows queries to call themselves repeatedly until a condition is met. This\nmakes it possible to analyze complex control flow and data flow patterns in\ncode.\n\nFinally, QL includes a rich type system that allows programmers to define and\nuse complex data types in their queries. This makes it possible to model complex\ndata structures and analyze them in a meaningful way.\n\nThe QL Core workshops are designed to provide participants with a comprehensive\nunderstanding of these other features of QL. Participants will learn how to use\nthese concepts to write effective queries for identifying security\nvulnerabilities in code. By the end of the workshops, participants will be able\nto use these features to write complex queries that can analyze even the most\nchallenging codebases.\n","topics":"QL Core"}]